<font size = 9>$$I/O 管理概述$$</font>


# 一、I/O 设备的概念

**I/O 设备** 指可以 **将数据输入计算机的外部设备**，或者可以 **接收计算机输出数据的外部设备**，属于计算机中的硬件部件。

- I/O 设备由 **机械部件** 和 **电子部件（I/O 控制器/设备控制器）** 组成。
  - **机械部件** 主要用来执行具体的 I/O 操作。
  - **电子部件** 通常是一块插入主板扩充槽的印刷电路板。





# 二、I/O 设备的分类

1. **按使用特性分类**：
   - **人机交互类外部设备**：鼠标、键盘、打印机等用于人机交互的设备。数据传输速度慢
   - **存储设备**：移动硬盘、光盘等用于数据存储的设备。数据传输速度快。
   - **网络通信设备**：调制解调器等用于网络通信（计算机与计算机之间的通信）的设备。数据传输速度介于上述二者之间。

2. **按传输速率分类**：
   - **低速设备**：鼠标、键盘等传输速率为每秒几个到几百个字节。
   - **中速设备**：激光打印机等传输速率为每秒数千到上万个字节。
   - **高速设备**：磁盘等，传输速率为每秒数千字节到千兆字节的设备。

3. **按信息交换的单位分类**：
   - **块设备**：磁盘等设备，数据传输的基本单位是“块”。**传输速率较高**，**可寻址**（可随机地读/写任一块）。
   - **字符设备**：鼠标、键盘等设备，数据传输的基本单位是字符。**传输速率较慢**，**不可寻址**，在输入/输出时 **常采用中断驱动方式（一种 I/O 控制方式）**。

4. **按设备的共享属性分类**：
   - **独占设备**：同一时刻只能有一个进程占用的设备。一旦将这类设备分配给某进程，便由该进程独占，直至用完释放。低速设备一般是独占设备，如打印机。
   - **共享设备**：同一时间段内允许多个进程同时访问的设备。典型的共享设备是磁盘。
   - **虚拟设备**：通过 SPOOLing 技术将独占设备改造为共享设备，将一个物理设备变为多个逻辑设备，从而可将设备同时分配给多个进程。





# 三、I/O 接口（I/O 控制器，设备控制器）

**I/O 接口（I/O 控制器，设备控制器）** 是 I/O 设备的 **电子部件**，是 CPU 与设备之间的“桥梁”，用于实现 **对 I/O 设备的控制** 以及 **设备和计算机之间的数据交换**。

- CPU 可控制 I/O 控制器，又由 I/O 控制器来控制设备的机械部件。

## 1. I/O 控制器的功能

1. **接收和识别 CPU 发出的命令**
   - I/O 控制器中会有相应的 **控制寄存器** 来存放命令和参数。

2. **标识和向 CPU 报告设备的状态**
    - I/O 控制器中会有相应的 **状态寄存器** 用于记录 I/O 设备的当前状态。

3. **数据交换**
    - I/O 控制器中会设置相应的 **数据寄存器**。
      - 输出时，数据寄存器用于暂存 CPU 发来的数据，之后再由控制器传送给设备。
      - 输入时，数据寄存器用于暂存设备发来的数据，之后 CPU 从数据寄存器中取走数据。

4. **地址识别**
    - 为了区分设备控制器中的各个寄存器，需要给各个寄存器设置一个特定的“地址”。
    - I/O 控制器通过 CPU 提供的“地址”来判断 CPU 要读/写的是哪个寄存器。

5. **数据缓冲**

6. **差错控制**




## 2. I/O 控制器的组成

**I/O 控制器** 主要由三部分组成：**设备控制器与 CPU 的接口**、**设备控制器与设备的接口**、**I/O 逻辑**。


1. **设备控制器与 CPU 的接口**
用于实现 CPU 与设备控制器之间的通信。
   - 该接口有三类信号线：
     - **数据线**：传送的是读/写数据、控制信息和状态信息。
     - **地址线**：传送的是要访问 I/O 接口中的寄存器编号。
     - **控制线**：传送的是读/写等控制信号。

2. **设备控制器与设备的接口**
用于实现设备控制器与设备之间的通信。
   - 一个设备控制器可以连接一个或多个设备，因此控制器中有一个或多个设备接口。
   - 每个接口都可以传输 **数据**（输入/输出数据）、**控制**（控制器向设备发出的控制信息） 和 **状态**（设备要反馈状态（忙碌/空闲）） 三种类型的信号。

3. **I/O 逻辑**
用于实现对设备的控制。负责接收和识别 CPU 的各种命令，并负责对设备发出命令。
   - I/O 逻辑通过一组控制线与 CPU 交互。
   - 对从 CPU 收到的 I/O 命令进行译码。
   - CPU 启动设备时，将启动命令发送给 I/O 控制器，同时通过地址线将地址发送给 I/O 控制器，由 I/O 控制器的 I/O 逻辑对地址进行译码，并对所选设备进行控制。

**注意**：
   - 一个 I/O 控制器可能会对应多个设备。
   - 数据寄存器、控制寄存器、状态寄存器可能有多个。
     - 这些寄存器要有相应的地址，才能方便 CPU 操作。
     - 有的计算机会让这些寄存器占用内存地址的一部分，即 **内存映像 I/O**。
     - 有的计算机会采用 I/O 专用地址，即 **寄存器独立编址**。




## 3. I/O 接口的类型

1. **按数据传送方式分类**
   - **并行接口**：一个字节或者一个字的所有位同时传送。
   - **串行接口**：一位一位地有序传送。
    *注意*：接口要完成数据格式的转换。

2. **按主机访问 I/O 设备的控制方式分类**
   - **程序查询接口**
   - **中断接口**
   - **DMA 接口**

3. **按功能选择的灵活性分类**
   - **可编程接口**（通过编程改变接口功能）
   - **不可编程接口**





# 四、I/O 端口

**I/O 端口** 指设备控制器中可被 CPU 直接访问的寄存器。


## 1. I/O 端口的分类
I/O 端口主要有三类寄存器。

- **数据寄存器**：用于缓存从设备送来的输入数据，或从 CPU 送来的输出数据。

- **状态寄存器**：保存设备的执行结果或状态信息，以供 CPU 读取。

- **控制寄存器**：由 CPU 写入，以便启动命令或更改设备模式。




## 2. 寄存器编址方式
需要对各个 I/O 端口进行 **编址** 才能被 CPU 访问。每个 I/O 端口对应一个 **端口地址**。

对 I/O 端口编址的方式有两种：与存储器 **独立编址** 和 **统一编址（内存映射 I/O）**。

1. **独立编址**
**独立编址** 是指为每个端口分配一个 I/O 端口号。
   - I/O 端口的地址空间与主存地址空间是两个独立的地址空间。
   - 用户程序不能对端口进行访问，只有操作系统使用特殊的 I/O 指令才能访问端口。
   - **优点**：
     - I/O 端口译码简单，寻址速度更快。因为 I/O 端口数比主存单元少得多，只需少量地址线。
     - 使用专用 I/O 指令，可使程序更加清晰，便于理解和检查。
   - **缺点**：
     - 需要设置专门的指令来实现对控制器的操作，不仅要指明寄存器的地址，还要指明控制器的编号，增加了控制的复杂性。
     - 程序设计的灵活性较差。I/O 指令少，只提供简单的传输操作。

2. **统一编址（内存映射 I/O）**
**内存映射 I/O** 把控制器中的寄存器与内存地址统一编址。
   - 将主存地址空间分出一部分给 I/O 端口进行编址，I/O 端口和主存单元在同一地址空间的不同分段中。
   - 根据地址范围就能区分访问的是 I/O 端口还是主存储单元。
   - 因此无需设置专门的 I/O 指令，用统一的访存指令就可访问 I/O 端口。
   - **优点**：
     - 简化了指令。不需要专门的 I/O 指令，可以采用对内存进行操作的指令来对控制器进行操作，使 CPU 访问 I/O 的操作更加灵活和方便，使得端口有较大的编址空间。
     - I/O 访问的保护机制可由虚拟存储管理系统来实现，无须专门设置。
   - **缺点**：
     - 端口地址占用了部分主存地址空间，使主存的可用容量变小。
     - 在识别 I/O 端口时全部地址线都需参加译码，使得译码电路更加复杂，降低了寻址速度。





# 五、I/O 控制方式

**I/O 控制** 是指控制设备和主机之间的数据传送。

- I/O 控制方式的发展过程就是要尽量减少 CPU 对 I/O 过程的干预，将 CPU 从烦杂的 I/O 控制事务中解脱出来。

**I/O 控制方式** 共有四种：**程序直接控制方式**、**中断驱动方式**、**DMA 方式**、**通道控制方式**。


## （一）程序直接控制方式

CPU 对 I/O 设备的控制采用轮询的 I/O 方式，即 **程序轮询** 方式。

1. **完成一次一个字（节）的读/写操作的流程为**：

    ```mermaid
    graph TB
        1[给 I/O 控制器发出读命令 <br> CPU --> I/O]
        2[读 I/O 控制器的状态 <br> I/O --> CPU]
        3{检查状态}
        4[从 I/O 控制器中读取字 <br> I/O --> CPU]
        5[往存储器中写入字 <br> CPU --> 存储字]
        6{完成？}

        subgraph 程序直接控制方式
            1 --> 2
            2 --> 3
            3 -->|准备好| 4
            4 --> 5
            5 --> 6
        end

        3 -->|未准备好| 2
        3 --> 7((错误条件))

        6 -->|否 <br>（读下一个字）| 1
        6 -->|是| 8((下一条指令))

        linkStyle 0,1,2,3,4,5,6,7,8 stroke:green
    ```

    1. CPU 向设备控制器发出一条 I/O 指令，启动从 I/O 设备读取一个字（节）。
    2. 将 I/O 状态信息读入 CPU 寄存器。
    3. 不断地循环测试设备状态（**轮询**），直到确定该字（节）已在设备控制器的数据寄存器中。
    4. 将数据寄存器中的内容读入 CPU 寄存器。
    5. CPU 将 CPU 寄存器中的内容送入内存的指定单元。

2. **CPU 干预的频率很频繁**。I/O 操作开始之前、完成之后需要 CPU 介入，并且 **在等待 I/O 完成的过程中 CPU 需要不断地轮询检查**。

3. **数据传送的单位**：每次读/写 **一个字**。

4. **数据的流向**
   - 读操作（数据输入）：I/O 设备 $\rightarrow$ CPU（指 CPU 的寄存器） $\rightarrow$ 内存
   - 写操作（数据输出）：内存 $\rightarrow$ CPU $\rightarrow$ I/O 设备
   - 每个字的读/写都需要 CPU 的帮助。

5. **优点**：实现简单。在读/写指令之后，加上实现循环检查的一系列指令即可（因此才称为“程序直接控制方式”）。

6. **缺点**：**CPU 和 I/O 设备只能串行工作，CPU 需要一直轮询检查，长期处于“忙等”状态**，CPU 利用率低。
   - CPU 之所以要不断地测试 I/O 设备的状态，就是因为在 CPU 中未采用中断机制，使 I/O 设备无法向 CPU 报告它已完成了一个字（节）的输入操作。




## （二）中断驱动方式

**中断驱动方式** 允许 I/O 设备主动打断 CPU 的运行并请求服务，从而“解放” CPU，使得 CPU 向设备控制器发出一条 I/O 指令后可以继续做其他有用的工作。
- **中断驱动方式** 引入 **中断机制**。

- 由于 I/O 设备速度很慢，因此在 CPU 发出读/写命令后，可 **将等待 I/O 的进程阻塞**，先切换到别的进程执行。

- 当 I/O 完成后，控制器会向 CPU 发出一个中断信号，CPU **检测到中断信号后**，会保存当前进程的运行环境信息，转去执行中断处理程序处理该中断。

- 处理中断的过程中，CPU 从 I/O 控制器读一个字的数据传送到 CPU 寄存器，在写入主存。

- 接着 **CPU 恢复等待 I/O 的进程（或其他进程）的运行环境，然后继续执行**。

**注意**：
  - CPU 会在每个指令周期的末尾检查中断。
  - 中断处理过程中需要保存、恢复进程的运行环境，这个过程需要一定的时间开销。所以，如果中断发生的频率太高，也会降低系统性能。

1. **完成一次读写操作的流程**：

    ```mermaid
    graph TB
        1[给 I/O 控制器发出读命令 <br> CPU --> I/O]
        2[读 I/O 控制器的状态 <br> I/O --> CPU]
        3{检查状态}
        4[从 I/O 控制器中读取字 <br> I/O --> CPU]
        5[往存储器中写入字 <br> CPU --> 存储字]
        6{完成？}

        subgraph 中断驱动方式
            1 --> 2
            2 --> 3
            3 -->|准备好| 4
            4 --> 5
            5 --> 6
        end

        1 -.-> 9((做其他事情))

        3 --> 7((错误条件))

        6 -->|否 <br>（读下一个字）| 1
        6 -->|是| 8((下一条指令))

        10((中断)) -.-> 2

        linkStyle 0,1,2,3,4,5,6,7,8,9 stroke:green
    ```

2. **CPU 干预的频率**
   - 每次 I/O 操作开始之前、完成之后需要 CPU 介入。
   - **等待 I/O 完成的过程中 CPU 可以切换到别的进程执行**。

3. **数据传送的单位** 为每次读/写 **一个字**。

4. **数据的流向**
   - 读操作（数据输入）：I/O 设备 $\rightarrow$ CPU $\rightarrow$ 内存
   - 写操作（数据输出）：内存 $\rightarrow$ CPU $\rightarrow$ I/O 设备

5. **优点**：I/O 控制器会通过中断信号主动报告 I/O 已完成，CPU 不再需要不停地轮询。在设备准备数据期间，**CPU 和 I/O 设备可并行工作**，CPU 的利用率得到明显提升到。

6. **缺点**：
   - 每个字在 I/O 设备与内存之间的传输，都需要经过 CPU 中的寄存器。**频繁的中断处理会消耗较多的 CPU 时间**。
   - CPU 是以字（节）为单位进行干预的，若这种方式用于块设备的 I/O 操作，则是极其低效的。因此，中断驱动 I/O 方法的速度仍然受限。




## （三）DMA 方式

**DMA（Direct Memory Access，直接存储器存取）方式** 在 I/O 设备和内存中间开辟 **直接的数据交换通路**，彻底“解放” CPU。

- DMA 方式主要用于块设备的 I/O 控制。

- DMA 方式的 **特点** 为：
  - **数据的传送单位是“块”**。不再是一个字、一个字传送。
  - 数据的流向是从设备直接放入内存，或者从内存直接到设备。不再经过 CPU。
  - 仅在传送一个或多个数据块的开始和结束时，才需要 CPU 干预。

- DMA 也是一种 I/O 控制器。

- **DMA 控制器的组成**：
    ```mermaid
    graph TB
        CPU ---|系统总线| DMA控制器
        内存 ---|系统总线| DMA控制器

        subgraph DMA控制器
            subgraph 主机 - 控制器接口
            direction TB
                1[DR]
                2[MAR]
                3[DC]
                4[CR]
            end
            
            5[I/O 控制逻辑]

            subgraph 块设备 - 控制器接口
                6[与块设备的接口]
            end
        end


        内存 <==> DMA控制器

        DMA控制器 <==> 磁盘

        linkStyle 0,1,2,3 stroke:green
    ```
    - DMA 控制器需要四类寄存器：
      - **数据寄存器（DR）**：暂存从设备到内存，或从内存到设备的数据。
      - **内存地址寄存器（MAR）**：在输入时，存放将数据从设备传送到内存的起始目标地址（数据应放到内存中的什么位置）；在输出时，存放由内存到设备的内存源地址（要输出的数据放在内存中的什么位置）。
      - **数据计数器（DC）**：存放本地要传送的字（节）数。（剩余要读/写的字节数）
      - **命令/状态寄存器（CR）**：暂存从 CPU 发来的 I/O 命令，或设备的状态信息。

1. **完成一次读写操作的流程**：

    ```mermaid
    graph TB
        1[给 I/O 模块发出读块命令 <br> CPU --> DMA]
        2[读 DMA 模块的状态 <br> DMA --> CPU]
        3((下一条指令))
        4((做其他事情))
        5((中断))

        subgraph DMA 方式
            1 --> 2
            2 --> 3
        end

        1 -.-> 4
        
        5 -.-> 2

        linkStyle 0,1,2,3 stroke:green
    ```
    1. CPU 接收到设备的 DMA 请求时，CPU 向 DMA 控制器发出一条指令。指明此次要进行的操作，并设置 DC 和 MAR 的初值，来说明要读入多少数据、数据要存放在内存的什么位置、数据在外部设备上的地址。启动 DMA 控制器，然后继续其他工作。
    2. 之后 CPU 将 I/O 控制权交给 DMA 控制器负责数据传送。DMA 控制器会根据 CPU 提出的要求直接与内存交互，每次传送一个字，完成数据的读/写工作。整块数据的传输完成后，DMA 控制器向 CPU 发出中断信号。

2. **CPU 干预的频率**：仅在传送一个或多个数据块的开始和结束时，才需要 CPU 干预。

3. **数据传送的单位**：每次读/写 **一个或多个块**。
**注意**：**每次读写的只能是连续的多个块，且这些块读入内存后在内存中也必须是连续的**。

4. **数据的流向**
   - 读操作（数据输入）：I/O 设备 $\rightarrow$ 内存
   - 写操作（数据输出）：内存 $\rightarrow$ I/O 设备

5. **优点**
   - 数据传输以“块”为单位，CPU 介入频率进一步降低。
   - 数据传送不再经过 CPU 的寄存器，数据传输效率进一步增加。CPU 和 I/O 设备的并行性得到提升。

6. **缺点**
   - CPU 每发出一条 I/O 指令，只能读/写一个或多个连续的数据块。
   - 如果要读/写多个离散存储的数据块，或者要将数据分别写到不同的内存区域时，CPU 要分别发出多条 I/O 指令，进行多次中断处理才能完成。




## （四）通道控制方式

**通道** 是一种硬件，是一种特殊的处理机，可以识别并执行一系列 **通道指令**。

- 通道与 CPU 的区别：
  - 通道指令的类型单一
  - 没有自己的内存，通道所执行的通道程序是放在主机的内存中的，也就是说通道与 CPU 共享内存。

- 通道与 DMA 方式的区别：
  - DMA 方式需要 CPU 控制传输的数据块大小、传输的内存位置，而通道方式中的这些信息是由通道控制的。
  - 每个 DMA 控制器对应一台设备与内存传递数据，而一个通道可以控制多台设备与内存的数据交换。

1. **完成一次读/写操作的流程**
    ```mermaid
    graph TB
        1[CPU 给通都发出指令]
        2[CPU 进行中断处理]
        3((执行后续操作))
        4((CPU 做其他事情，通道自主完成 I/O))
        5((中断信号))

        subgraph 通道控制方式
            1 --> 2
            2 --> 3
        end

        1 -.-> 4
        
        5 -.-> 2

        linkStyle 0,1,2,3 stroke:green
    ```
   1. CPU 向通道发出 I/O 指令。指明通道程序在内存中的位置，并指明要操作的是哪个 I/O 设备。之后 CPU 就切换到其他进程执行了。
   2. 通道收到该指令后，执行内存中的通道程序（其中指明了要读入/写出多少数据，读/写的数据应放在内存的什么位置等信息）
   3. 通道执行完规定的 I/O 任务后，向 CPU 发出中断信号，之后 CPU 对中断进行处理。

2. **CPU 干预的频率**：极低。通道会根据 CPU 的指示执行相应的通道程序，只有完成一组数据块的读/写后才需要发出中断信号，请求 CPU 干预。

3. **数据传送的单位**：每次读/写 **一组数据块**。

4. **数据的流向（在通道的控制下进行）**
   - 读操作（数据输入）：I/O 设备 $rightarrow$ 内存
   - 写操作（数据输出）：内存 $rightarrow$ I/O 设备

5. **优点**：**CPU、通道、I/O 设备可并行工作，资源利用率很高**。

6. **缺点**：实现复杂，需要专门的通道硬件支持。





# 六、I/O 软件层次结构

I/O 软件普遍采用 **层次结构的 I/O 软件**，使复杂的 I/O 软件能具有清晰的结构、良好的可移植性和易适应性。

- **层次结构的 I/O 软件** 将系统中的设备管理模块分为若干层次，每层都是利用其下一层提供的服务，完成输入/输出功能中的某些子功能，并屏蔽这些功能实现的细节向高层提供服务。
   @import "IO层次结构.png"

- 在层次结构的 I/O 软件中，只要层次间的接口不变，对某一次中的软件的修改不会引起下层或高层代码的变更，仅最低层才涉及硬件的具体特性。

整个 I/O 软件可以视为具有 4 个层次的系统架构：**用户层软件**、**设备独立性软件**、**设备驱动程序**、**中断处理程序**。

- **设备独立性软件**、**设备驱动程序**、**中断处理程序** 属于 **操作系统内核部分** 即，**I/O 系统（I/O 核心子系统）**。


## 1. 用户层软件

用户层软件 **实现了与用户交互的接口**。

- 用户可直接调用该层提供的、与 I/O 操作有关的库函数，对设备进行操作。

- 用户层软件将用户请求翻译成格式化的 I/O 请求，并通过“系统调用”请求操作系统内核的服务。




## 2. 设备独立性软件

**设备独立性软件（设备无关性软件）** 用于实现用户程序与设备驱动器的同一接口、设备命名、设备保护，以及设备的分配与释放等，同时为设备管理和数据传送提供必要的存储空间。

- 设备独立性软件 **主要实现的功能** 有：
  - **向上层提供同一的调用接口**。
  - **设备的保护**。设备被看作是一种特殊的文件，不同用户对设备的访问权限也不一样。
  - **差错处理**。对一些设备的错误进行处理。
  - **设备的分配与回收**。
  - **数据缓冲区管理**。可以通过缓冲技术屏蔽设备之间数据交换单位大小和传输速度的差异。
  - 建立 **逻辑设备名到物理设备名之间的映射关系**，根据设备类型选择调用相应的驱动程序。
    - 用户或用户层软件发出 I/O 操作相关的系统调用时，需要指明此次要操作的 I/O 设备的 **逻辑设备名**。（使用逻辑设备名来请求使用某类设备）
    - **设备独立性软件** 需要通过“**逻辑设备表（LUT，Logical Unit Table）**”来确定逻辑设备对应的 **物理设备**，并找到该设备对应的**设备驱动程序**。

      |逻辑设备名|物理设备名|驱动程序入口地址|
      |:-------:|:-------:|:-------------:|
      - 操作系统可以采用两种方式管理 **逻辑设备表（LUT）**
        - 第一种方式：**整个系统只设置一张 LUT**，即所有用户不能使用相同的逻辑设备名，因此这种方式只适用于单用户操作系统。
        - 第二种方式：**为每个用户设置一张 LUT**，各个用户使用的逻辑设备名可以重复，适用于多用户操作系统。系统会在用户登录时为其建立一个用户管理进程，而 LUT 就存放在用户管理进程的 PCB 中。
  - **提供独立于设备的大小统一的逻辑块，屏蔽设备之间信息交换单位大小和传输速率的差异**。




## 3. 设备驱动程序

每类设备需要配置一个 **设备驱动程序**，主要负责对硬件设备的具体控制，将上层发出的一系列命令转化成特定设备“能听懂的”一系列操作。包括设置设备寄存器，检查设备状态等。

- 不同的 I/O 设备有不同的硬件特性，因此厂家需要根据设备的硬件特性设计并提供相应的驱动程序。

*注意*：驱动程序一般会以一个独立进程的方式存在。是 I/O 进程与设备控制器之间的通信程序。




## 4. 中断处理程序

当 I/O 任务完成时，I/O 控制器会发送一个 **中断信号**，CPU 响应中断后，会 **根据中断信号类型** 找到相应的 **中断处理程序** 并执行，处理完后，再返回到被中断的进程。

- 中断处理层的 **主要任务**：
  - 进行进程上下文的切换
  - 对处理中断信号源进行测试
  - 读取设备状态和修改进程状态

- 中断处理程序的 **处理流程**：

   ```mermaid
   graph TB
      1[从控制器读出设备状态]
      2{I/O 正常结束}
      3[从设备中读入一个字的数据并经由 CPU 放到内存缓冲区中]
      4[根据异常原因做相应处理]

      1 --> 2
      2 -->|是| 3
      2 -->|否| 4

      linkStyle 0,1,2 stroke:white
   ```





# 七、输入/输出应用程序接口

## （一）I/O 接口的分类

用户层的应用程序无法用一个统一的 **系统调用接口** 来完成所有类型设备的 I/O，所以在 I/O 系统与高层之间的接口中，根据设备类型的不同可以分为 **字符设备接口**、**块设备接口**、**网络设备接口**。


## 1. 字符设备接口

**字符设备** 是指数据的存取和传输是以字符为单位的设备，传输速率较低、不可寻址，只能采取顺序存取方式，在输入/输出时通常采用中断驱动方式。如键盘、打印机等。

- **get/put 系统调用**：向字符设备的字符缓冲区读/写一个字符。

- 字符设备属于独占设备，所以接口还需提供打开和关闭操作，以实现互斥共享。




## 2. 块设备接口

**块设备** 是指数据的存取和传输是以数据块为单位的设备。传输速率较高、可寻址。典型的块设备是磁盘，磁盘设备的 I/O 常采用 DMA 方式。

- **read/write 系统调用**：向块设备的 **读写指针位置** 读/写多个字符。

- **seek 系统调用**：**修改读写指针位置**。




## 3. **网络设备接口**

**网络设备接口（网络套接字（soket）接口）** 是操作系统为了提供面向网络的功能，使计算机能够通过网络与网络上的其他计算机进行通信或上网浏览的网络软件和网络通信接口。

- 套接字接口的系统调用使应用程序创建的本地套接字连接到远程应用程序创建的套接字，通过此连接发送和接收数据。

- **socket 系统调用**：**创建一个网络套接字**，需指明网络协议。

- **bind 系统调用**：将套接字绑定到某个本地“**端口**”。

- **connect 系统调用**：将套接字连接到远程地址。

- **read/write 系统调用**：从套接字读/写数据。





## （二）阻塞 I/O 和非阻塞 I/O

操作系统的 I/O 接口分为两种模式：**阻塞** 和 **非阻塞**。

1. **阻塞 I/O**：应用程序发出 I/O 系统调用，**进程需转为阻塞态等待**。
   - 当用户进程调用 I/O 操作时，进程就被阻塞，并一道阻塞队列，I/O 操作完成后，进程才被唤醒，移到就绪队列。
   - 当进程恢复执行时，它收到系统调用的返回值，并继续处理程序。
   - 大多数操作系统提供的 I/O 接口都是采用阻塞 I/O。
   - **优点**：操作简单，实现难度低，适合并发量小的应用开发。
   - **缺点**：I/O 执行阶段进程会一直阻塞下去。

2. **非阻塞 I/O**：应用程序发出 I/O 系统调用，系统调用可迅速返回，**进程无需阻塞等待**。
   - 当用户进程调用 I/O 操作时，不阻塞该进程。
   - 进程需要不断询问 I/O 操作是否完成，在 I/O 执行阶段，进程还可以做其他事情。
   - 当问到 I/O 操作完成后，系统将数据从内核复制到用户空间，进程继续处理数据。
   - **优点**：进程在等待 I/O 期间不会阻塞，可以做其他事情，适合并发量大的应用开发。
   - **缺点**：轮询方式询问 I/O 结果，会占用 CPU 的时间。





# 八、设备驱动程序接口

为了使操作系统能更容易地调用设备驱动程序，操作系统要规定号设备驱动程序的接口标准。

- 不同的操作系统，对设备驱动程序接口的标准各不相同。