<font size = 9>$$进程同步与进程互斥$$</font>


# 一、进程同步

**同步（直接制约关系）**：为完成某种任务而建立的两个或多个进程，这些进程需要在某些位置上 **协调** 它们的 **工作次序** 而产生的制约关系。

- 进程间的直接制约关系（同步关系）就是源于它们之间的相互合作。

- 解决 **异步** 问题，就是 **进程同步** 所讨论的问题。
  - 进程具有 **异步性**（各并发执行的进程以各自独立的、不可预知的速度向前推进）。





# 二、进程互斥

**临界资源**：**一个时间段内只允许一个进程使用** 的资源。

- 对临界资源的访问，必须 **互斥（间接制约关系）** 地进行。

**进程互斥**：当一个进程进入临界区使用临界资源时，另一个进程必须等待，当占用临界资源的进程退出临界区后，另一个进程才允许去访问临界资源。

- **临界资源的访问过程**：
  1. **进入区**：负责检查是否可以进入临界区，若可进入，则应 **设置** **正在访问临界资源的标志**（上锁），以阻止其他进程同时进入临界区。
  2. **临界区（临界段）**：访问临界资源的那段代码。
  3. **退出区**：负责 **解除** **正在访问临界资源的标志**（解锁）。
  4. **剩余区**：代码中的其余部分，用来做其他处理。

  *注意*：**进入区** 和 **退出区** 是 **负责实现互斥** 的代码段。

- 为禁止两个进程同时进入临界区，**实现对临界资源的互斥访问**，同时保证系统整体性能，**同步机制应遵循以下原则**：
  1. **空闲让进**：临界区空闲时，可以允许一个请求进入临界区的进程立即进入临界区。
  2. **忙则等待**：当已有进程进入临界区时，其他试图进入临界区的进程必须等待。
  3. **有限等待**：对请求访问的进程，应保证能在有限时间内进入临界区，防止进程无限等待。（保证不会饥饿）
  4. **让权等待**：当进程不能进入临界区时，应立即释放处理机，防止进程忙等待（等待无法使用的资源，但仍然占用处理机）。





# 三、进程互斥的软件实现方法

**软件实现方法**：
- 在 **进入区设置并检查一些标志** 来标明 **是否有进程在临界区中**。
- 若 **已有进程在临界区**，则在 **进入区通过循环检查进行等待**。
- 进程 **离开临界区后** 则在 **退出区修改标志**。

## （一）单标志法

1. **算法思想**：两个进程在 **访问完临界区后** 会把使用临界区的权限转交给另一个进程。即 **每个进程进入临界区的权限只能被另一个进程赋予**。

2. **算法规则**：
   1. 设置一个 **公共整型变量 turn**，表示 **允许进入临界区的进程编号**。
   2. 当 **turn = 0** 时，表示 **允许 $P_0$ 进入临界区**。
   3. 当 **turn = 1** 时，表示 **允许 $P_1$ 进入临界区**。 
   4. **进程退出临界区时**，将临界区的使用权交给另一个进程，**修改 trun 的值为对方的值**。

    标志：
    ```
    int turn = 0;       // turn 表示当前允许进入临界区的进程号。初值为 0，即刚开始只允许 0 号进程进入临界区
    ```

    $P_0$ 进程：
    ```
    while(turn != 0);   // 进入区
    critical section;   // 临界区
    turn = 1;           // 退出区
    remainder section;  // 剩余区
    ```

    $P_1$ 进程：
    ```
    while(turn != 1);   // 进入区
    critical section;   // 临界区
    turn = 0;           // 退出区
    remainder section;  // 剩余区
    ```

- 两个进程必须 **交替进入** 临界区。

3. **优点**：**可以实现同一时刻最多只允许一个进程访问临界区**。

4. **缺点**：**违背“空闲让进”原则**。如果此时允许进入临界区的进程一直不访问临界区，那么虽然此时临界区空闲，但仍不允许另一个进程访问。即，**只能交替进入，而不能同一进程连续进入**。




## （二）双标志先检查法

1. **算法思想**：
   1. 设置一个 **布尔型数组 flag[]**，数组中各个元素用来 **标记各进程想进入临界区的意愿**。
   2. 每个进程在进入临界区之前先 **检查当前有没有别的进程想进入临界区**。
   3. **如果没有**，则 **把自身对应的标志 flag[i] 设为 true**（上锁），之后开始访问临界区。
   4. **访问完临界区**，**把自身对应的标志 flag[i] 修改为 false**（解锁）。

    标志：
    ```
    bool flag[2];     // 表示进入临界区意愿的数组
    flag[0] = false;  // 刚开始设置为两个进程都不想进入临界区
    flag[1] = false;
    ```

    $P_0$ 进程：
    ```
    while(flag[1]);     // 进入区，检查当前有没有别的进程想进入临界区
    flag[0] = true;     // 进入区，上锁
    cirtical section;   // 临界区
    flag[0] = false;    // 退出区，解锁
    remainder section;  // 剩余区
    ```

    $P_1$ 进程：
    ```
    while(flag[0]);     // 进入区，检查当前有没有别的进程想进入临界区
    flag[1] = true;     // 进入区，上锁
    cirtical section;   // 临界区
    flag[1] = false;    // 退出区，解锁
    remainder section;  // 剩余区
    ```

2. **优点**：不用交替进入，**可连续使用**。

3. **缺点**：在并发环境下，**两个进程可能同时进入临界区**，**违反“忙则等待”原则**。因为，**进入区** 的“检查”和“上锁” **两个处理不是一气呵成的**（没有原子性）。




## （三）双标志后检查法

1. **算法思想**：把双标志先检查法的先“检查”后“上锁” **修改为先“上锁”后“检查”**。

    标志：
    ```
    bool flag[2];     // 表示进入临界区意愿的数组
    flag[0] = false;  // 刚开始设置为两个进程都不想进入临界区
    flag[1] = false;
    ```

    $P_0$ 进程：
    ```
    flag[0] = true;     // 进入区，先上锁
    while(flag[1]);     // 进入区，后检查当前有没有别的进程想进入临界区
    cirtical section;   // 临界区
    flag[0] = false;    // 退出区，解锁
    remainder section;  // 剩余区
    ```

    $P_1$ 进程：
    ```
    flag[1] = true;     // 进入区，先上锁
    while(flag[0]);     // 进入区，后检查当前有没有别的进程想进入临界区
    cirtical section;   // 临界区
    flag[1] = false;    // 退出区，解锁
    remainder section;  // 剩余区
    ```

2. **优点**：**解决了“忙则等待”**。

3. **缺点**：
   - **违背了“空闲让进”和“有限等待”原则**。
   - 当两个进程都先各自上完锁后，然后各自进行检查时，都会发现对方也想进入，从而都进行等待。最后会因各进程都长期无法访问临界资源而 **产生“饥饿”** 现象。




## （四）Peterson 算法

1. **算法思想**：结合单标志法和双标志后检查法的思想。如果双方都想进入临界区，利用 flag[] 解决互斥访问问题，利用 turn 解决“饥饿”问题。

2. **算法规则**：
   1. **表达意愿**：表示想要进入临界区，修改进程相对应的 flag[i] 为 true。
   2. **谦让**：先让对方进程进入。修改 turn 为对方的进程号。
   3. **检查**：检查对方进程是否想用，且最后表示谦让的是否是自己。如果是自己且对方想用，就等待。
   4. 访问临界资源
   5. 访问完后修改访问意愿 flag[i] 为 false。

    标志：
    ```
    bool flag[2];     // 表示进入临界区意愿的数组
    flag[0] = false;  // 刚开始设置为两个进程都不想进入临界区
    flag[1] = false;

    int turn = 0;     // turn 表示优先让哪个进程进入临界区（表达“谦让”）
    ```

    $P_0$ 进程：
    ```
    flag[0] = true;                  // 进入区，先表达意愿
    turn = 1;                        // 进入区，谦让
    while(flag[1] && turn == 1);     // 进入区，检查对方进程是否想用，且最后表示谦让的是否是自己
    cirtical section;                // 临界区
    flag[0] = false;                 // 退出区，解锁
    remainder section;               // 剩余区
    ```

    $P_1$ 进程：
    ```
    flag[1] = true;                  // 进入区，先表达意愿
    turn = 0;                        // 进入区，谦让
    while(flag[0] && turn == 0);     // 进入区，查对方进程是否想用，且最后表示谦让的是否是自己
    cirtical section;                // 临界区
    flag[1] = false;                 // 退出区，解锁
    remainder section;               // 剩余区
    ```

3. **优点**：解决了进程互斥问题，**遵循来空闲让进、忙则等待、有限等待三个原则**。

4. **缺点**：依然 **未遵守让权等待** 的原则。即使没有进入临界区，执行 while 循环仍会占用 CPU。





# 四、进程互斥的硬件实现方法

计算机提供了特殊的硬件指令，允许对一个字的内容进行检测和修正，或对两个字的内容进行交换。

## （一）中断屏蔽方法

**中断屏蔽方法** 利用 **“开/关中断指令”** 实现。（与原语的实现思想相同）因为 CPU 只在发生中断时引起进程切换，所以屏蔽中断能保证当前运行的进程让临界区代码顺利地执行完，进而保证互斥的正确实现，然后执行开中断。

- 中断屏蔽方法的典型模式：
    ```
    关中断;
    临界区;
    开中断;
    ```

- **优点**：简单、高效。

- **缺点**：
  - **只适用于单处理机，不适用于多处理机**。因为在一个 CPU 上关中断并不能防止进程在其他 CPU 上执行相同的临界区代码。
  - **只适用于操作系统内核进程，不适用于用户进程**。因为开/关中断指令只能运行在内核态，这组指令如果能让用户随意使用会很危险。若一个进程关中断后不再开中断，则系统可能因此终止。
  - 限制了 CPU 交替执行程序的能力，系统效率明显降低。




## （二）硬件指令方法 —— TestAndSet 指令

**TestAndSet 指令（TS 指令/TestAnSetLock 指令/TSL 指令）** 的功能是 **读出指定标志** 后 **将该标志置为真**。

**TS 指令** 是 **用硬件实现的**，是 **一条硬件指令**，是 **原子操作**，执行过程不允许被中断。

- **TS 指令的功能逻辑描述**：
    ```
    // 共享的布尔型变量 lock 表示当前临界区是否被加锁
    // true  表示已加锁
    // false 表示未加锁
    bool TestAndSet(bool *lock) {
        bool old;
        old = *lock;    // old 用来存放 lock 原来的值
        *lock = true;   // 无论之前是否已加锁，都将 lock 置为 true
        return old;     // 返回 lock 原来的值
    }
    ```

- **使用 TS 指令实现互斥的算法逻辑**：**用 TS 指令 检查 lock 值**。
  -  若为 **false**，则表示没有进程在临界区，**可以进入**，并 **将 lock 置为 true**，即上锁。
  -  若为 **true**，则表示有进程在临界区，**进入循环等待**，**直到当前访问临界区的进程退出时解锁**（将 lock 置为 false）。
    ```
    while(TestAndSet(&lock));  // 检查并上锁
    进程的临界区代码段;
    lock = false;              // 解锁
    剩余区代码段;
    ```

- **优点**：
  - 实现简单。
  - 适用于多处理机系统。

- **缺点**：**不满足“让权等待”原则**。暂时无法进入临界区的进程会占用 CPU 并循环执行 TS 指令，从而导致“忙等待”。




## （三）硬件指令方法 —— Swap 指令

**Swap 指令（Exchange 指令/XCHG 指令）** 的功能是 **交换两个字（字节）的内容**。

**Swap 指令** 是 **用硬件实现的**，是 **一条硬件指令**，是 **原子操作**，执行过程中不允许被中断。

- **Swap 指令的功能逻辑描述**：
    ```
    Swap(bool *a, bool *b) {
        bool temp;
        temp = *a;
        *a = *b;
        *b = temp;
    }
    ```

- **使用 Swap 指令实现互斥的算法逻辑**：
  - 在每个进程中设置一个局部布尔型变量 key，用于与 lock 交换信息。初值为 true。
  - 为每个临界资源设置一个共享布尔型变量 lock，初值为 false。
  - 先通过 key 查看此时临界区是否已加锁。
  - 再将锁标志 lock 设为 true。
  - 最后检查 key
    - 如果 key 为 false，则说明之前没有别的进程对临界区上锁，可以跳出循环，进入临界区。
    - 如果 key 为 true，则说明临界区之前已被别的进程上锁，进入循环等待。
  ```
  bool key = true;
  while(key != false)
    Swap(&lock, &key);
  进程的临界区代码段;
  lock = false;
  进程的其他代码;
  ```

- **优点**：
  - 简单、容易验证其准确性。
  - 适用于多处理器系统，适用于任意数量的进程。
  - 支持系统中有多个临界区，只需为每个临界区设立一个布尔变量。

- **缺点**：
  - **不满足“让权等待”原则**，暂时无法进入临界区的进程会占用 CPU 并循环执行 Swap 指令，从而导致“忙等”。
  - 从等待进程中随机选择一个进程进入临界区，有的进程可能一直都选不上，从而**导致“饥饿”现象**。





# 五、互斥锁

**互斥锁** 是解决临界区的最简单的 **工具**。

- 互斥锁的规则：
  - 一个进程在 **进入临界区** 时 **调用 acquire() 函数**，**获得锁**。
  - 一个进程在 **退出临界区** 时 **调用 release() 函数**，**释放锁**。
  - 每个互斥锁有一个 **布尔型变量 abailable**，表示锁是否可用。
    - 如果 **锁可用**，则可成功调用 acquire() 函数，且 **修改锁为不可再用**。
    - 如果一个进程想要获取 **不可用的锁**，就 **会被阻塞**，**直到锁被释放**。
  
  acquire() 函数：
  ```
  acquire() {
      while(!available);  // 忙等待
      available = false;  // 获得锁
  }
  ```
  release() 函数：
  ```
  release() {
      available = true;  // 释放锁
  }
  ```

- acquire() 或 release() 的执行必须是 **原子操作**，因此互斥锁通常采用硬件机制来实现。

- **自旋锁**：需要连续循环忙等的互斥锁。如：单标志法、TSL 指令、swap 指令。

- 自旋锁的 **优点**：进程在等待锁期间，**没有上下文切换**，若上锁的时间较短，则等待代价不高。

- 自旋锁的 **缺点**：**忙等待**，进程时间片用完才会下处理机，违反 **让权等待**。当有一个进程在临界区，任何其他进程在进入临界区时必须连续循环调用 acquire()。当多个进程共享一个 CPU 时，就浪费了 CPU 周期。因此，互斥锁 **通常用于多处理器系统**，一个线程可以在一个处理机上等待，不影响其他线程的执行。






# 六、信号量机制

**信号量机制**：用户进程可以通过使用操作系统提供的 **一对原语（由开中断/关中断指令实现）** 来对 **信号量** 进行操作，从而很方便的实现了进程互斥、同步。

- **一对原语** 指 **wait() 原语**（**P()** 或 **P 操作**）和 **signal() 原语**（**V()** 或 **V 操作**），可以用于 **实现系统资源的“申请”和“释放”**。

- **信号量** 就是一个变量（**可以是一个整数，也可以是更复杂的记录型的数据结构的变量**），可用用一个信号量来 **表示系统中某种资源的数量**。

1. **整型信号量**：一个 **用于表示资源数量** 的 **整型量 S**。
   - 对整型信号量的操作只有三种：**初始化**、**P 操作**、**V 操作**。
   - wait 操作和 signal 操作描述
      - **wait 操作描述**：
        ```
        void wait(int S) {  // wait 原语相当于进入区
            while(S <= 0);  // 如果资源数量不够，就一直循环等待
            S = S - 1;      // 如果资源数够，则占用一个资源
        }
        ```
      - **signal 操作描述**：
        ```
        void signal(int S) {  // signal 原语相当于退出区
            S = S + 1;        // 使用完资源后，就在退出区释放一个资源
        }
        ```
   - 利用整型信号量 **实现进程互斥**
        ```
        int S = 1;  // 初始化整型信号量 S，初值为 1,表示当前系统中可用的资源数

        // 进程 P1
        P1() {
            ...
            P(S);             // 进入区，申请资源，加锁
            进程 P1 的临界区;  // 临界区，访问资源
            V(S);             // 退出区，释放资源，解锁
            ...
        }

        // 进程 P2
        P2() {
            ...
            P(S);             // 进入区，申请资源，加锁
            进程 P2 的临界区;  // 临界区，访问资源
            V(S);             // 退出区，释放资源，解锁
            ...
        }
        ```
    - 利用整型信号量 **实现进程同步**（要让各并发进程按要求有序地推进）
      - 必须保证“**一前一后**”执行两个操作，实现同步关系。
      - 设置 **同步信号量 S**，**初始为 0**。
      - **在“前操作”之后执行 V(S)**。
      - **在“后操作”之前执行 P(S)**。

        保证 **代码 4 一定是在 代码 2 之后执行**：
        ```
        int S = 0;  // 初始化同步信号量 S，初值为 0，表示刚开始没有这种资源。需要先由 进程P1 产生，进程P2 才能使用

        // 进程 P1
        P1() {
            代码 1;
            代码 2;  // 执行 代码 2
            V(S);   // 告诉进程 P2,代码 2 已执行完成
            代码 3;
        }

        // 进程 P2
        P2() {
            P(S);    // 检查 代码 2 是否已执行完成
            代码 4;  // 获得 代码 2 的执行结果，执行代码 4
            代码 5;
            代码 6;
        }
        ```
   - **缺点**：**未遵循“让权等待”原则**。整型信号量机制的 wait 操作，只要 $信号量 S \leq 0$，就会不断循环测试，使进程处于“忙等”状态。


2. **记录型信号量**：用记录型数据结构表示的信号量。
   - 记录型信号量机制是一种不存在“忙等”现象的进程同步机制。
     - 一个用于代表 **资源数量的整型变量 value**。
     - **进程链表 L**，用于链接所有等待该资源的进程。

    记录型信号量的定义：
    ```
    typedef struct {
        int value;          // 剩余资源数
        struct process *L;  // 等待队列
    } semaphore;
    ```
    - 相应的 wait(S) 和 signal(S) 操作为：
      - **wait 操作描述**：
        ```
        void wait(Semahore S) {  // wait 操作相当于资源申请
            S.value--;           // 请求该类资源，使系统中可供分配的该类资源数减 1
            if(S.value < 0) {    // 如果该类资源以分配完
                block(S.L);      // 调用 block 原语使进程从运行态进入阻塞态，并把进程挂到该类资源的等待队列 S.L 中。
            }
        }
        ```
      - **signal 操作描述**：
        ```
        void signal(semaphore S) {  // signal 操作相当于释放资源
            S.value++;              // 释放一个该类资源，使系统中可供分配的该类资源数加 1
            if(S.value <= 0) {      // 如果资源数量仍小于 0, 则表示仍有进程在等待该类资源
                wakeup(S.L);        // 调用 wakeup 原语将 S.L 中的第一个进程唤醒
            }
        }
        ```
   - 利用记录型信号量 **实现进程互斥**
        ```
        Semaphore S;  // 声明一个记录型互斥信号量 S
        S.value = 1;  // 初始化信号量为 1, 表示可用资源为 1
        S.L = NULL;   // 初始化进程链表 L 为空

        // 进程 P1
        P1() {
            ...
            P(S);             // 进入区，申请资源，加锁
            进程 P1 的临界区;  // 临界区，访问资源
            V(S);             // 退出区，释放资源，解锁
            ...
        }

        // 进程 P2
        P2() {
            ...
            P(S);             // 进入区，申请资源，加锁
            进程 P2 的临界区;  // 临界区，访问资源
            V(S);             // 退出区，释放资源，解锁
            ...
        }
        ```
    - 利用记录型信号量 **实现进程同步**（要让各并发进程按要求有序地推进）
      - 必须保证“**一前一后**”执行两个操作，实现同步关系。
      - 设置 **同步信号量 S**，**初始为 0**。
      - **在“前操作”之后执行 V(S)**。
      - **在“后操作”之前执行 P(S)**。

        保证 **代码 4 一定是在 代码 2 之后执行**：
        ```
        semaphore S = 0;  // 初始化同步信号量 S，初值为 0，表示刚开始没有这种资源。需要先由 进程P1 产生，进程P2 才能使用

        // 进程 P1
        P1() {
            代码 1;
            代码 2;  // 执行 代码 2
            V(S);   // 告诉进程 P2,代码 2 已执行完成
            代码 3;
        }

        // 进程 P2
        P2() {
            P(S);    // 检查 代码 2 是否已执行完成
            代码 4;  // 获得 代码 2 的执行结果，执行代码 4
            代码 5;
            代码 6;
        }
        ```
    - **优点**：**遵循“让权等待”原则**。


**注意**：
   - 若无特别说明，P(S)、V(S) 的操作 **默认 S 为记录型信号量**。
   - 对 **不同的临界资源** 需要 **设置不同的互斥信号量**。
   - **P、V 操作必须成对出现**。
     - 缺少 P() 就不能保证临界资源的互斥访问。
     - 缺少 V() 会导致资源用不被释放，等待进程永不被唤醒。
   - **有多少资源就把信号量初值设为多少**。


3. 信号量机制 **实现前驱关系**

    **信号量** 也可用来描述程序或语句之间的前驱关系。

    ```mermaid
    graph TB
        S1((S1)) --a12--> S2((S2))
        S1 --a13--> S3((S3))
        S2 --a24--> S4((S4))
        S2 --a25--> S5((S5))
        S3 --a36--> S6((S6))
        S4 --a46--> S6
        S5 --a56--> S6

        linkStyle 0,1,2,3,4,5,6 stroke:white,stroke-width:1px,color:black;
    ```
    **每一对前驱关系都是一个进程同步问题**（需要保证一前一后的操作）。
     1. **分析问题，画出前驱图**，把每一对前驱关系都看成一个同步问题。
     2. 要 **为每一对前驱关系设置一个同步信号量**。
     3. **在“前操作”之后，对相应的同步信号量执行 V 操作**。
     4. **在“后操作”之前，对相应的同步信号量执行 P 操作**。
    ```
    semaphore a12 = a13 = a24 = a25 =  a36 = a46 = a56;  // 初始化各个前驱关系的同步信号量

    P1() {
        ...
        S1;
        V(a12);  // S1 已运行完成
        V(a13);
    }

    P2() {
        ...
        P(a12);  // 检查 S1 是否运行完成
        S2;
        V(a24);  // S2 已运行完成
        V(a25);
        ...
    }

    P3() {
        ...
        P(a13);  // 检查 S1 是否运行完成
        S3;
        V(a36);  // S3 已运行完成
    }

    P4() {
        ...
        P(a24);  // 检查 S2 是否运行完成
        S4;
        V(a46);  // S4 已运行完成
        ...
    }

    P5() {
        ...
        P(a25);  // 检查 S2 是否运行完成
        S5;
        V(a56);  // S5 已运行完成
        ...
    }

    P6() {
        ...
        P(a36);  // 检查 S3 是否运行完成
        P(a46);  // 检查 S4 是否运行完成
        P(a56);  // 检查 S5 是否运行完成
        S6;      // 运行 S6
        ...
    }
    ```





# 七、经典互斥同步问题

PV 操作题目分析步骤：
1. 关系分析。找出题目中描述的各个进程，分析它们之间的同步、互斥关系。
2. 整理思路。根据各进程的操作流程确定 P、V 操作的大致顺序。
3. 设置信号量。并根据题目条件确定信号量初值。（互斥信号量初值一般为 1, 同步信号量初值要看对应资源有多少）

## （一）生产者 —— 消费者问题

### 1. 问题描述

- 系统中有 **一组生产者进程** 和 **一组消费者进程**。生产者进程每次生产一个产品（某种数据）放入缓冲区，消费者进程每次从缓冲区中取出一个产品并使用。

- 生产者和消费者共享一个 **初始为空、大小为 n 的缓冲区**。

- 只有 **缓冲区没满** 时，生产者才能把产品放入缓冲区，否则必须等待。

- 只有 **缓冲区不空** 时，消费者才能从中取出产品，否则必须等待。

- 缓冲区是临界资源，该进程必须 **互斥地访问**。



### 2. 问题分析

1. 关系分析
   - 同步关系：
     - 缓冲区没满 $\rightarrow$ 生产者生产
     - 缓冲区没空 $\rightarrow$ 消费者消费

   - 互斥关系：各进程必须互斥地访问缓冲区。

2. 整理思路：
    ```mermaid
    graph LR
        1(缓冲区没满) ==V() full P()==> 2(生产者生产)
        3(缓冲区没空) ==V() empty P()==> 4(消费者消费)

        linkStyle 0,1 stroke:white,stroke-width:5px,color:black;
    ```

3. 设置信号量：
   - **互斥信号量**：设置信号量 mutex 作为互斥信号量，用于控制互斥访问缓冲区，互斥信号量初值为 1 
   - **同步信号量**
     - 信号量 empty，表示空闲缓冲区的数量
     - 信号量 full，表示产品的数量，即非空缓冲区的数量



### 3. 实现

```
semaphore mutex = 1;  // 互斥信号量，实现对缓冲区的互斥访问
semapaore empty = n;  // 同步信号量，表示空缓冲区的数量
semaphore full = 0;   // 同步信号量，表示产品的数量，即非空缓冲区的数量

// 生产者
producer() {
    while(1) {
        生产一个产品;
        P(empty);  // 消耗一个空闲缓冲区
        P(mutex);  // 上锁
        把产品放入缓冲区;
        V(mutex);  // 解锁
        V(full);   // 增加一个产品
    }
}

// 消费者
consumer() {
    while(1) {
        P(full);   // 消耗一个产品（非空缓冲区）
        P(mutex);  // 上锁
        从缓冲区取出一个产品;
        V(mutex);  // 解锁
        V(empty);  // 增加一个空闲缓冲区
        使用产品；
    }
}
```

- 实现互斥是在同一进程中进行一对 PV 操作。

- 实现两进程的同步关系，是在其中一个进程中执行 P，另一进程中执行 V。

- **实现互斥的 P 操作一定要在实现同步的 P 操作之后**，否则会导致死锁。

- V 操作不会导致进程阻塞，因此 **两个 V 操作顺序可以交换**。




## （二）多生产者 —— 消费者问题

### 1. 问题描述

桌上有一只盘子，每次只能向其中放入一个水果。爸爸专向盘子中放苹果，妈妈专向盘子中放橘子，儿子专等着吃盘子中的橘子，女儿专等着吃盘子中的苹果。只有盘子空时，爸爸或妈妈才可向盘子中放一个水果。仅当盘子中有自己需要的水果时，儿子或女儿可用从盘子中取出水果。



### 2. 问题分析

1. 关系分析
   - 互斥关系：对缓冲区（盘子）的访问要互斥进行。
   - 同步关系（**一前一后**）
     - 父亲将苹果放入盘子后，女儿才能取苹果。
     - 母亲将橘子放入盘子后，儿子才能取橘子。
     - 只有 **盘子为空** 时，**父亲或母亲** 才能放入水果。（“盘子为空”这个事件可以由儿子或女儿触发，事件发生后才允许父亲或母亲放水果）

2. 整理思路

    ```mermaid
    graph LR
        subgraph 1
        direction TB
            父亲
            母亲
        end
        subgraph 2
        direction LR
            盘子plate
        end
        subgraph 3
        direction TB
            女儿
            儿子
        end

        父亲 --V() apple P()--> 女儿
        父亲 ---|P| 盘子plate
        盘子plate ---|V| 女儿
        母亲 ---|P| 盘子plate
        盘子plate ---|V| 儿子
        母亲 --V() orange P()--> 儿子

        linkStyle 0,1,2,3,4,5 stroke:green,stroke-width:3px,color:black;
    ```

3. 设置信号量
    - 互斥信号量：mutex = 1, 对缓冲区互斥地进行访问。
    - 同步信号量：
      - apple = 0，父亲将苹果放入盘子后，女儿才能取水果。
      - oragne = 0，母亲将橘子放入盘子后，儿子才能取水果。
      - plate = 1，只有盘子为空时，父亲或母亲才能放入水果。



### 3. 实现

```
semaphore mutex = 1;   // 互斥信号量，实现互斥访问盘子
semaphore apple = 0;   // 同步信号量，盘子中有几个苹果
semaphore orange = 0;  // 同步信号量，盘子中有几个橘子
semaphore plate = 1;   // 同步信号量，盘子中还可以放几个水果

// 父亲进程
dad() {
    while(1) {
        准备一个苹果;
        P(plate);  // 检查是否能放入水果
        P(mutex);  // 加锁
        把苹果放入盘子;
        V(mutex);  // 解锁
        V(apple);  // 允许取苹果
    }
}

// 母亲进程
mom() {
    while(1) {
        准备一个橘子;
        P(plate);  // 检查是否能放入水果
        P(mutex);  // 加锁
        把橘子放入盘子;
        V(mutex);  // 解锁
        V(orange);  // 允许取橘子
    }
}

// 女儿进程
daughter() {
    while(1) {
        P(apple);  // 检查是否能取苹果
        P(mutex);  // 加锁
        从盘中取出苹果;
        V(mutex);  // 解锁
        V(plate);  // 允许放水果
        吃掉苹果;
    }
}

// 儿子进程
son() {
    while(1) {
        P(orange);  // 检查是否能取橘子
        P(mutex);  // 加锁
        从盘中取除橘子;
        V(mutex);  // 解锁
        V(plate);  // 允许放水果
        吃掉橘子;
    }
}
```

- **即使不设置专门的互斥变量 mutex，也不会出现多个进程同时访问盘子的现象**。因为这里的缓冲区大小为 1，在任何时刻，apple、orange、plate 三个同步信号量最多只有一个是 1。因此在任何时刻，最多只有一个进程的 P 操作不会被阻塞，并顺利地进入临界区。

- **如果缓冲区大小大于 1，就必须专门设置一个互斥信号量 mugtex 来保证互斥访问缓冲区**。

**注意**：实现互斥的 P 操作一定要在实现同步的 P 操作之后。




## （三）读者 —— 写者问题

### 1. 问题描述

有读者和写者两组并发进程，共享一个文件，当两个或两个以上的读进程同时访问共享数据时不会产生副作用，但若某个写进程和其他进程（读进程或写进程）同时访问共享数据时则可能导致数据不一致的错误。因此要求：1. 允许多个读者可以同时对文件进行读操作；2. 只允许一个写者往文件中写信息；3. 任一写者在完成写操作之前不允许其他读者或写者工作；4. 写者执行写操作前，应让已有的读者和写者全部退出。



### 2. 问题分析

1. 关系分析
   - 互斥关系：写进程 —— 写进程、写进程 —— 读进程。读进程与读进程之间不存在互斥关系。

2. 信号量设置
   1. 设置一个互斥信号量 rw，用来实现对共享文件的互斥访问。
   2. 设置一个计数器 count，用来记录当前正在访问共享文件的读进程数。可以用 count 的值来判断当前进入的进程是否是第一个/最后一个读进程，从而做出不同的处理。
   3. 设置一个互斥信号量 mutex，用于实现对 count 变量的互斥访问。
   4. 设置一个互斥信号量 w，用于实现“写优先”。



### 3. 实现

```
semaphore rw =  1;    // 用于实现对共享文件的互斥访问
int count = 0;        // 记录当前有几个读进程在访问文件
semaphore mutex = 1;  // 用于保证对 count 变量的互斥访问
semaphore w = 1;      // 用于实现“写优先”

// 写进程
writer() {
    while(1) {
        P(w);   // 在无写进程请求时进入
        P(rw);  // 互斥访问共享文件
        写文件;
        V(rw);  // 释放共享文件
        V(w);   // 恢复对共享文件的访问
    }
}

// 读进程
reader() {
    while(1) {
        P(w);           // 在无写进程请求时进入
        P(mutex);       // 互斥访问 count 变量
        if(count == 0)  // 当第一个读进程读共享文件时
            P(rw);      // 阻止写进程写
        count++;        // 读者计数器加 1
        V(mutex);       // 释放互斥变量 count
        V(w);           // 恢复对共享文件的访问
        读文件;
        P(mutex);       // 互斥访问 count 变量
        count--;        // 读者计数器减 1
        if(count == 0)  // 当最后一个读进程读完共享文件
            V(rw);      // 允许写进程写
        V(mutex);       // 释放互斥变量 count
    }
}
```

- 这种算法称为 **读/写公平法**。连续进入的多个读者可以同时读文件；写者和其他进程不能同时访问文件；写者不会饥饿，但也并不是真正的“写优先”，而是相对公平的先来先服务原则。



## （四）哲学家进餐问题

### 1. 问题描述

一张圆桌上坐着 5 名哲学家，每两个哲学家之间的桌上摆一根筷子，桌子的中间是一碗米饭。哲学家们倾注毕生的精力用于思考和进餐，哲学家在思考时并不影响其他人。只有当哲学家饥饿时，才试图拿起左、右两个筷子（一根一根地拿起）。如果筷子已在他人手上，则需等待。饥饿的哲学家只有同时拿起两根筷子才可以开始进餐，当进餐完毕后，放下筷子继续思考。



### 2. 问题分析

1. 关系分析
   系统中有 5 个哲学家进程，5位哲学家与左右邻居对其中间筷子的访问是互斥关系。

2. 信号量设置
   定义互斥信号量数组 chopstick = {1, 1, 1, 1, 1} 用于实现对 5 个筷子的互斥访问。并对哲学家按 0 ~ 4 编号，哲学家 i 左边的筷子编号为 i，右边的筷子编号为 (i + 1) % 5。



### 3. 实现

1. 方案一：至多允许 4 名哲学家同时进餐，以保证至少有一名哲学家能拿到左右两边的筷子。

2. 方案二：仅当一名哲学家左右两边的筷子都可用时，才允许他拿起筷子。
    ```
    semaphore chopstick[5] = {1, 1, 1, 1, 1};  // 初始化信号量
    semaphore mutex = 1;                       // 设置取筷子的信号量

    Pi() {
        while(1) {
            P(mutex);                   // 对取筷子操作上锁
            P(chopstick[i]);            // 取左边的筷子
            P(chopstkck[(i + 1) % 5]);  // 取右边的筷子
            V(mutex);                   // 对取筷子操作解锁
            进餐;
            V(chopstick[i]);            // 放回左边的筷子
            V(chopstick[(i + 1) % 5]);  // 放回右边的筷子
            思考;
        }
    }
    ```

3. 方案三：对哲学家顺序编号，要求奇数号哲学家先拿左边的筷子，然后拿右边的筷子，而偶数号哲学家刚好相反，以保证相邻的两名哲学家都想进餐时，只有一名哲学家可以拿起第一根筷子，而另一名哲学家会被阻塞。





# 八、管程

**管程** 是代表共享资源的数据结构，以及由对该共享数据结构实时操作的一组过程所组成的资源管理程序。（类似面向对象程序设计中的“类”）

- 管程定义了一个数据结构和能为并发进程所执行（在该数据结构上）的一组操作，这组操作能同步进程和改变管程中的数据。

- 管程是一种特殊的软件模块，由 4 部分组成：
  1. 管程有一个名字
  2. 局部用于管程的 **共享数据结构** 说明。
  3. 对该数据结构进行操作的 **一组过程（函数）**。
  4. 对局部于管程的共享数据设置初始值的语句。

- 管程的基本特征：
    1. 局部于管程的数据只能被局部于管程的过程所访问；
    2. 一个进程只有通过调用管程内的过程（函数）才能进入管程访问共享数据；
    3. **每次仅允许一个进程在管程内执行某个内部过程**。

- 由编译器负责实现各进程互斥地进入管程中的过程（函数）。

- 可在管程中设置条件变量及等待/唤醒操作以解决同步问题。