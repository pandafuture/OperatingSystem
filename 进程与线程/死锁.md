<font size = 9>$$死锁$$</font>


# 一、死锁的概念

**死锁**：**各个进程互相等待对方手里的资源，导致各进程都阻塞，无法向前推进的现象**。

- **饥饿**：由于长期得不到想要的资源，某进程无法向前推进的现象。

- **死循环**：某进程执行过程中一直跳不出某个循环的现象。有时是因为程序逻辑 bug 导致的，有时是程序员故意设计的。

- **共同点**：都是进程无法顺利向前推进的现象。（故意设计的死循环除外）

- **区别**：
  - **死锁**：**至少有两个或两个以上的进程同时发生死锁**。发生死锁的进程 **一定处于阻塞态**。
  - **饥饿**：**可能只有一个进程发生饥饿**。发生饥饿的进程 **可能是阻塞态，也可能是就绪态**。
  - **死循环**：**可能只有一个进程发生死循环**。死循环的进程 **可以上处理机运行**（可以是运行态）。
  - **死锁和饥饿是管理者（操作系统）的问题，死循环是被管理者（程序员）的问题**。





# 二、死锁产生的条件

产生死锁必须同时满足四个条件，只要其中任一条件不成立，死锁就不会发生。

1. **互斥条件**：只有对必须互斥使用的资源的争抢才会导致死锁。

2. **不可剥夺条件**：进程所获得的资源在未使用完之前，**不能由其他进程强行夺走**，只能主动释放。

3. **请求并保持条件**：进程 **已经保持了至少一个资源**，但又提出了新的资源 **请求**，而该资源又被其他进程占有，此时请求进程被阻塞，但又对自己已有的资源 **保持** 不放。

4. **循环等待条件**：存在一种进程 **资源的循环等待链**，链中的每一个进程已获得的资源同时被下一个进程所请求。

**注意**：**发生死锁时一定有循环等待，但是发生循环等待时未必死锁**。如果同类资源数大于 1,则即使有循环等待，也未必发生死锁。（如有第六个哲学家，手上还有一根筷子）但如果系统中每类资源都只有一个，那循环等待就是死锁的充分必要条件类。





# 三、死锁产生的原因

1. **系统资源的竞争**：各进程对不可剥夺的资源（如打印机）的竞争可能引起死锁，对可剥夺的资源（如CPU）的竞争不会引起死锁。

2. **进程推进顺序非法**：请求和释放资源的顺序不当，也同样会导致死锁。

3. **信号量使用不当**：进程间彼此相互等待对方发来的消息，也会使得这些进程无法继续向前推进。





# 四、死锁的处理策略

1. **预防死锁**：设置某些限制条件，破坏死锁产生的四个必要条件中的一个或几个。

2. **避免死锁**：在资源的动态分配过程中，用某种方法防止系统进入不安全状态，从而避免死锁。

3. **死锁的检测和解除**：无需采取任何限制性措施，允许死锁的发生，不过操作系统会负责检测出死锁的发生，然后采取某种措施解除死锁。


## （一）预防死锁

预防死锁的发生只需破坏死锁产生的 4 个必要条件之一即可。

1. **破坏互斥条件**
如果 **把只能互斥使用的资源改造为允许共享使用**，则系统不会进入死锁状态。如：SPOOLing 技术。

   - **缺点**：并不是所有的资源都可以改造成可共享使用的资源。并且为了系统安全，很多地方还必须保护这种互斥性。因此 **可行性不高，很多时候都无法破坏互斥条件**。

2. **破坏不可剥夺条件**
**方案一**：当某个进程 **请求新的资源得不到满足时，它必须立即释放保持的所有资源**，待以后需要时再重新申请。也就是说，即使某些资源尚未时用完，也需要主动释放，从而破坏了不可剥夺条件。
**方案二**：当某个进程 **需要的资源被其他进程所占用的时候，可以由操作系统协助，将想要的资源强行剥夺**。这种方式一般需要 **考虑各种进程的优先级**。
   - **缺点**：
     - **实现起来比较复杂**。
     - 释放已获得的资源 **可能造成前一阶段的工作的失效**。因此这种方法一般只适用于易保存和恢复状态的资源，如 CPU。
     - **反复地申请和释放资源会增加系统开销**，降低系统吞吐量。
     - 若采用方案一，意味着只要暂时得不到某个资源，之前获得的哪些资源就都需要放弃，以后再重新申请。如果一直发生这样的情况，就会 **导致饥饿**。

3. **破坏申请和保持条件**
**方案一**：可以 **采用预先静态分配方法**，即进程在 **运行前一次申请完它所需要的全部资源**，在它的资源未满足前，不让它投入运行。一旦投入运行后，**这些资源就一直归它所有**，该进程就不会在请求别的任何资源了。
   - **优点**：实现起来简单。
   - **缺点**：
     - 有些资源可能只需要用很短的时间，因此如果进程的整个运行期间都一直保持着所有资源，就会造成严重的资源浪费，**资源利用率极低**。
     - **可能导致某些进程饥饿**。由于个别资源长期被其他进程占用，将导致等待该资源的进程迟迟不可能开始运行。
   - 改进方案一的缺点，**方案二**：运行进程只获得运行初期所需的资源，便可开始运行。进程在运行过程中再逐步释放已分配给自己且已使用完毕的全部资源后，才能请求新的资源。

1. **破坏循环等待条件**
采用 **顺序资源分配法**。首先给系统中的资源编号，规定每个进程 **必须按编号递增的顺序请求资源**，同类资源（即编号相同的资源）一次申请完。
   - 原理分析：一个进程只有已占有小编号的资源时，才有资格申请更大编号的资源。按此规则，已持有大编号资源的进程不可能逆向地回来申请小编号的资源，从而就不会产生循环等待的现象。即，在任何一个时刻，总有一个进程拥有的资源编号是最大的，那这个进程申请之后的资源必然畅通无阻。因此，不可能出现所有进程都阻塞的死锁现象。
   - **缺点**：
     - **不方便增加新的设备**。因为可能需要重新分配所有的编号。
     - 进程实际使用资源的顺序可能和编号递增顺序不一致，**会导致资源浪费**。
     - 必须按规定次序申请资源，**用户编程麻烦**。




## （二）避免死锁

**避免死锁** 属于事先预防策略。在每次分配资源的过程中，都要分析此次分配是否回带来死锁风险，只有在不产生死锁的情况下，系统才会为其分配资源。

避免死锁的方法中，运行进程动态地申请资源，但系统在继续资源分配之前，应先 **计算此次分配的安全性**。若此次分配不会导致系统进入 **不安全状态**，则允许分配；否则让进程等待。
   - **安全状态**：系统能按某种进程推进顺序（$P_1$, $P_2$,..., $P_n$）为每个进程 $P_i$ 分配其所需的资源，直至满足每个进程对资源的最大需求，使每个进程都可顺利完成。

   - **安全序列**：$P_1$, $P_2$,..., $P_n$ 即为安全序列。如果系统按照这种序列分配资源，则每个进程都能顺利完成。只要能找出一个安全序列，系统就是 **安全状态**。

   - **不安全状态**：如果分配量资源之后，系统中找不出任何一个安全序列，系统就进入了不安全状态。意味着之后 **可能** 所有进程都无法顺利地执行下去。

   - **安全序列可能有多个**。

   - 如果有进程提前归还了一些资源，那 **系统也有可能重新回到安全状态**，不过在分配资源之前总是要考虑到最坏的情况。

   - 如果系统处于 **安全状态**，就 **一定不会** 发生 **死锁**。如果系统进入 **不安全状态**，就 **可能** 发生 **死锁**（处于不安全状态未必就是发生了死锁，但发生死锁时一定是在不安全状态）。


**银行家算法**
银行家算法是一种死锁避免算法。
1. **核心思想**：**在资源分配之前预先判断这次分配是否会导致系统进入不安全状态**，以此决定是否答应资源分配请求。

2. **数据结构描述**
    假设 **系统中有 n 个进程，m 种资源**。
   1. **最大需求矩阵 Max**：$n * m$ 矩阵（可用二维数组实现），表示 **所有进程对各种资源的最大需求数**。
      - 定义系统中 n 个进程中的每个进程对 m 类资源的最大需求。
      - $Max[i,j] = K$ 表示进程 $P_i$ 最多需要 K 个资源 $R_j$。
   2. **分配矩阵 Allocation**：$n * m$ 矩阵，表示 **对所有进程的资源分配情况**。
      - 定义系统中每类资源当前已分配给每个进程的资源数。
      - $Allocation[i,j] = K$ 表示进程 $P_i$ 当前已分得 $R_j$ 类资源的数量为 K。
   3. **需求矩阵 Need**：$n * m$ 矩阵，表示 **每个进程最多还需要多少各类资源**。
      - $Need = Max - Allocation$
      - $Need[i,j] = K$ 表示进程 $P_i$ 还需要 $R_j$ 类资源的数量为 K。
   4. **可利用资源向量 Available**：长度为 m 的一维数组，表示 **当前系统中还有多少可用资源**。
      - $Acailable[j] = K$ 表示此时系统中有 K 个 $R_j$ 类资源。
   5. **请求向量 $Request_i$**：长度为 m 的一维数组 $Request_i$，表示 **进程 $P_i$ 向系统申请资源，本次申请的各种资源量**。
      - $Request_i[j] = K$ 表示进程 $P_i$ 需要 j 类资源 K 个。

3. **算法描述**
    1. 如果 $Request_i[j] \leq Need[i,j]，（0 \leq j \leq m）$ 便转向 2；否则认为出错。
         - 即，**检查此次请求的资源是否超过了最大需求数量**。如果未超过，则此次申请合理，可以继续进行；否则认为不合理，因为它所申请的资源数已超过它所宣布的最大值。
    2. 如果 $Request_i[j] \leq Available[j]，（0 \leq j \leq m）$ 便转向 3；否则表示尚无足够资源，$P_i$ 必须等待。
         - 即，**检查此次申请的资源数量是否超过类系统中的剩余的可用资源数量**。如果未超过，则此次申请合理，可以继续继续；否则表示尚无足够资源，进程必须等待。
    3. 系统 **试探着** 把资源 **分配** 给进程 $P_i$，并 **修改相应的数据**（**并非真的分配，修改数值只是为了做预判**）：
         - $Available = Available - Request_i$，分配完后修改可利用资源数
         - $Allocation[i,j] = Allocation[i,j] + Request_i[j]$，修改进程的资源分配情况
         - $Need[i,j] = Need[i,j] - Request_i[j]$，修改进程的资源需求。
    4. 操作系统执行 **安全性算法**，检查此次资源分配后，系统 **是否处于安全状态**。若安全，才正式分配；否则，恢复相应数据，让进程阻塞等待。




## （三）死锁的检测和解除

如果系统中即不采取预防死锁的措施，也不采取避免死锁的措施，系统就很 **可能发生死锁**。在这种情况下，系统应当提供两个算法：
- 死锁检测算法：用于检测系统状态，以确定系统中是否发生类死锁。
- 死锁解除算法：当认定系统中已经发生了死锁，利用该算法可将系统从死锁状态中解脱出来。

1. **死锁检测**：**依次消除与不阻塞进程（申请的资源数还足够的进程）相连的边，直到无边可消**。
    - 用 **某种数据结构** 来保存资源的请求和分配信息；
    - 提供 **一种算法**，利用上述信息来检测系统是否已进入死锁状态。
    1.  **数据结构：资源分配图**
        ```mermaid
        graph LR
            1(资源分配图) --> 2(两种节点) & 3(两种边)
            2 --> 4(进程节点：对应一个进程（一般用圆圈表示）) & 5(资源节点：对应一类资源，一类资源可能有多个（一般用矩形表示，矩形中的小圆点代表该资源的数量）)
            3 --> 6(进程节点 ——> 资源节点：请求边，表示进程想申请几个资源（每条边代表一个）) & 7(资源节点 ——> 进程节点：分配边，表示已经为进程分配了几个资源（每条边代表一个）)

            linkStyle 0,1,2,3,4,5 stroke:white,stroke-width:4px,color:black
        ```
    2. **死锁检测思想**
       1. 如果系统中剩余的可用资源数足够满足进程的需求，那么这个进程暂时不会阻塞，可用继续顺利地执行下去。
       2. 如果这个进程执行结束了把资源归还系统，就可能使某些正在等待资源的进程被激活，并顺利地执行下去。
       3. 相应的，这些被激活的进程执行完之后又会归还一些资源，这样可能又会激活另外一些阻塞的进程。
       4. 如果按上述过程分析，最终 **能消除所有边**，就称这个图是 **可完全简化的**。此时一定 **没有发生死锁**（相当于能找到一个安全序列）。
       5. 如果最终 **不能消除所有边**，那么此时就是 **发生了死锁**。**最终还连着边的哪些进程就是处于死锁状态的进程**。
    3. **死锁检测算法**
         1. 在资源分配图中，找出即不阻塞又不是孤点的进程 $P_i$
            - 不阻塞，指系统中剩余的资源足够满足这个进程申请的需求
            - 不是孤点，指至少有一条边与该进程相连
         2. 消去它所有的请求边和分配边，使之成为孤立的结点。
         3. 进程 $P_i$ 所释放的资源，可用唤醒某些因等待这些资源而阻塞的进程，原来的阻塞进程可能变为非阻塞进程。
         4. 若能消去图中所有的边，则称该图是 **可完全简化的**。
    - **死锁定理**：如果某时刻系统的资源分配图是 **不可完全简化** 的，那么此时系统 **死锁**。

2. **死锁解除**：
   1. **资源剥夺法**：挂起（暂时放到外存上）某些死锁进程，并抢占它的资源，将这些资源分配给其他的死锁进程。但是应防止被挂起的进程长时间得不到资源而饥饿。
   2. **撤销进程法（终止进程法）**：强制撤销部分、甚至全部死锁进程，并剥夺这些进程资源。这种方式的优点是实现简单，但所付出的代价可能会很大。因为有些进程可能已经运行类很长时间，已经接近结束了，一旦被终止可谓功亏一篑，以后还得从头再来。
   3. **进程回退法**：让一个或多个死锁进程回退到足以避免死锁的地步。这要求系统要记录进程的历史信息，设置还原点。
    - 可以先对进程优先级低的处理
    - 已执行时间少的
    - 让剩余完成时间少的进程先执行
    - 把拥有更多资源的进程挂起
    - 交互式的进程保留，批处理式的进程先挂起