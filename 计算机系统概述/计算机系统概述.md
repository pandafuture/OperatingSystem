# 计算机系统的概述

## 一、操作系统的概念
**操作系统（Operating System，OS）** 是指**控制** 和 **管理** 整个计算机系统的 **硬件和软件** 资源，并合理地组织调度计算机的工作和资源的分配；以 **提供给用户和其他软件方便的接口和环境**；它是计算机系统中最基本的 **系统软件**。
1. 操作系统是系统资源的管理者。
2. 操作系统向上层提供方便易用的服务。
3. 操作系统是最接近硬件的一层软件。




## 二、操作系统的功能和目标
1. 操作系统作为 **计算机系统资源的管理者**。需要实现：**处理机管理**、**存储器管理**、**文件管理**、**设备管理**。

2. 操作系统作为 **用户与计算机硬件系统之间的接口**。主要提供两类接口，分别为 **命令接口** 和 **程序接口**。
   1. **命令接口**：用来组织和控制作业的执行。
      1. **联机命令接口（交互式命令接口）**：联机命令是由一组键盘操作命令组成。用户说一句，系统做一句。
      2. **脱机命令接口（批处理命令接口）**：脱机命令由一组作业控制命令组成。用户说一堆，系统做一堆。
   2. **程序接口**：可以在程序中进行 **系统调用（广义指令，是应用程序请求操作系统服务的唯一方式）** 来实现程序接口。普通用户不能直接使用程序接口，只能通过程序代码间接使用（类似于程序员调用C语言库函数来间接使用程序接口）。
   3. **图形用户界面（GUI）**：即 **图形接口**。狭义的用户接口不包含GUI，只包含命令接口和程序接口。

3. 操作系统实现了 **对计算机资源的扩充**。实现 **对硬件机器的拓展**，在 **裸机**（没有任何软件支持的计算机）上安装的操作系统，可以提供资源管理功能和方便用户的服务功能，将裸机改造成功能更强、使用更方便的机器。
    - **扩充机器（虚拟机）**：覆盖了软件的机器。




## 三、操作系统的特征
操作系统有 **并发**、**共享**、**虚拟**、**异步** 四个基本特征。其中并发和异步是 **两个最基本的特征，二者互为存在条件**。

1. **并发**：指两个或多个事件在同一 **时间间隔内** 发生。这些事件 **宏观上是同时发生** 的，但 **微观上是交替发生** 的。
    - **并发** 与 **并行** 不同。并行是指两个或多个事件在 **同一时刻** 同时发生。
    - **操作系统的并发性** 指计算机系统中“同时”运行着多个程序，这些程序宏观上看是同时运行着的，而微观上看是交替运行的。

**注意**：**单核CPU** **同一时刻** 只能执行 **一个程序**，各个程序只能 **并发** 地执行。
$\qquad$ $\,$**多核CPU** **同一时刻** 可以同时执行 **多个程序**，多个程序可以 **并行** 地执行。

2. **共享（资源共享）**：指系统中的资源可供内存中多个并发执行的进程共同使用。
   主要有两种资源 **共享方式** ：**互斥共享方式** 和 **同时共享方式**。
   - **互斥共享方式**：**一个时间段内只允许一个进程访问该资源**。
   - **同时共享方式**：**一个时间段内可允许多个进程“同时（宏观上）”访问该资源**。

**并发和共享的关系**：**互为存在条件**。
  - 共享以并发性为条件，如果系统不允许程序并发执行，那就不存在资源共享问题。
  - 如果失去共享性，则无法并发执行。

3. **虚拟**：指把一个物理上的实体变为若干个逻辑上的对应物。物理实体是实际存在的，而逻辑上的对应物是虚拟的，是用户感受到的。
   - **虚拟技术** 是用于实现虚拟的技术。操作系统的虚拟技术可分为 **空分复用技术（如虚拟存储器技术）** 和 **时分复用技术（如虚拟处理器技术）**
   - 从时分复用技术可知，如果没有并发性，就不需要虚拟性。

4. **异步**：在多道程序环境下，允许多个程序并发执行，但由于资源有限，进程的执行不是一贯到底的，而是走走停停，以不可预知的速度向前推进，这就是进程的异步性。
    - 只有系统拥有并发性，才可能导致异步性。




## 四、操作系统的发展历程

### （一） 手工操作阶段（此阶段无操作系统）
- **缺点**：**用户独占全机**、**人机速度矛盾导致资源利用率极低**。



### （二）批处理阶段（操作系统开始出现）
为了解决人机速度矛盾，出现了 **批处理系统**，其中先后发展出了 **单道批处理系统** 和 **多道批处理系统**。

1. **单道批处理系统（操作系统的雏形）**：引入 **脱机输入/输出技术（将一批作业以脱机方式把数据输入磁带，再以同样的方式把结果输出到另一个磁带）**，并由 **监督程序** 负责控制作业的输入、输出。
   - **特点**：
     - **自动性**
  磁带上的一批作业可以自动地逐个运行。
     - **顺序性**
  磁带上的各道作业按顺序进入内存，先进入的先完成。
     - **单道性**
  监督程序每次从磁带上只调入一道程序进入内存运行，只有完成或发生异常时，才换后继程序。
   - **优点**：缓解了一定程度的人机速度矛盾，资源利用率有所提升。
   - **缺点**：**内存中仅能有一道程序运行**，各个程序间串行运行；**CPU有大量的时间在空闲等待I/O完成**，资源利用率依然很低。

1. **多道批处理系统（操作系统正式诞生）**：引入**多道程序设计技术（提高单机资源利用率的关键技术）**。用于支持多道程序并发运行。将用户提交的作业成批地送入内存，然后由 **作业调度程序** 自动选择作业运行。
   - **多道程序设计** 的基本特征：
     - **复杂性**：多道程序的运行环境比单道程序的运行环境更加复杂。
     - **失去** 了 **封闭性** 和 **顺序性**
     - **制约性**、**共享性**：程序执行因为共享资源及相互协同的原因产生了竞争，相互制约。
     - **中断性**：考虑到竞争的公平性，程序的执行是断续的。
   - **特点**：
     - **多道**：计算机内存中同时存放多道相互独立的程序。
     - **宏观上并行**：同时进入系统的多道程序都处于运行过程中，但都未运行完毕。
     - **微观上串行**：内存中的多道程序轮流占有CPU，交替执行。
   - **优点**：多道程序 **并发** 执行（需要 **中断功能** 支持），**共享** 计算机资源，**资源利用率大幅提升**；CPU和其他资源更能保持“忙碌”状态，**系统吞吐量增大**。
   - **缺点**：用户响应时间长；**没有人机交互功能**



### （三）分时操作系统（可交互的操作系统）
**分时操作系统**：基于 **分时技术**，计算机以 **时间片** 为单位 **轮流为各个用户/作业服务**，各个用户可以通过终端与计算机进行交互。

- **分时技术**：将处理器的运行时间分成很短的时间片，按时间片轮流将处理器分配给各联机作业使用。

- 分时操作系统主要用于 **交互式作业**，而非批处理作业。

- **特点**：
  - **同时性（多路性）**：允许多个终端用户同时使用一台计算机。
  - **交互性**：用户通过终端采用人机对话的方式直接控制程序运行，与程序进行交互。
  - **独立性**：多个用户彼此独立，互不干扰。
  - **及时性**：用户请求能在很短时间内获得响应。

- **优点**：用户请求可以被即时响应，响应时间好，**解决了人机交互问题**；允许多个用户同时使用一台计算机，并且用户对计算机的操作相互独立，感受不到别人的存在。

- **缺点**：**不能优先处理一些紧急任务**，只能公平地循环地为每个用户服务一个时间片。



### （四）实时操作系统（可处理紧急任务的操作系统）
**实时操作系统** 能在某个时间限制内完成某些紧急任务而不需要时间片排队。在实时操作系统的控制下，计算机系统接收到外部信号后及时进行处理，并且 **要在严格的时限内处理完事件**。

- **时间限制** 分为两种情况，分别为**硬实时系统（必须在绝对严格的规定时间内完成处理）** 和 **软实时系统（能接受偶尔违反事件规定）**

- **目标**：**实时性** 和 **可靠性**。资源利用率不是实时操作系统的主要目标，即为了保证快速处理高优先级任务，允许“浪费”一些系统资源。

- **特点**：**及时性** 和 **可靠性**。

- **优点**：能够优先响应一些紧急任务，某些紧急任务不需时间片排队。

- 交互性不如分时系统。



### （五）网络操作系统
**网络操作系统**：是伴随计算机网络的发展而诞生的，能把网络中各个计算机有机地结合起来，实现数据传送等功能，**实现网络中各种资源的共享（如文件共享）和各台计算机之间的通信**。

- 服务于计算机网络，集中控制方式。



### （六）分布式计算机系统
**分布式计算机系统**：用于管理分布式计算机系统的操作系统。系统中各台计算机地位相同，**任何工作都可以分布在这些计算机上，有它们并行、协同完成这个任务**。

- **特点**：**分布性** 和 **并行性**。

- 建立在网络操作系统上，控制功能均为分布式。



### （七）个人计算机操作系统
**个人计算机系统** 是目前使用最广泛的操作系统。方便个人使用。




## 五、操作系统的运行机制

### （一）处理器的运行模式
1. 程序运行的过程其实就是CPU执行一条一条的机器 **指令（处理器CPU能识别、执行的最基本命令）** 的过程。

2. 处理器（CPU）执行两种不同性质的程序：**内核程序** 和 **应用程序**。

3. **操作系统内核（内核）**：由很多 **内核程序** 组成。是操作系统最核心的部分，是整个系统的 **管理者**，也是 **最接近硬件的部分**。

4. **内核的内容**
   1. **时钟管理**：时钟部件提供两个功能。
      1. **计时**：操作系统通过时钟管理，向用户提供标准的系统时间。
      2. **通过时钟中断的管理，实现进程的切换**。
   2. **中断机制**
   3. **原语**：是一种特殊的程序。处于操作系统的最底层，是最接近硬件的部分。这种程序的运行具有 **原子性**，即其运行只能一气呵成，不可中断。运行时间较短，调用频繁。
   4. **系统控制的数据结构及处理**：为了实现对系统中用来登记状态信息的数据结构的有效管理，系统需要一些基本操作。常见的有：**进程管理**、**存储器管理**、**设备管理**。

5. 特权指令与非特权指令
操作系统内核可以使用 **特权指令（不允许用户直接使用的指令）**
应用程序只能使用 **非特权指令（运行用户直接使用的指令）**

1. 内核态与用户态
为了 **区分** 正在运行的程序是 **内核程序** 还是 **应用程序** CPU划分了两种状态：**内核态（核心态/管态）** 和 **用户态（目态）**。
   - 处于 **内核态** 时，说明此时正在 **运行的是内核程序**，此时 **可以执行特权指令**。
   - 处于 **用户态** 时，说明此时正在 **运行的是应用程序**，此时 **只能执行非特权指令**。
   - CPU中有一个 **程序状态字寄存器（PSW）**，其中有个二进制位，1 表示“内核态”，0 表示“用户态”。

1. 内核态、用户态的切换
   - **内核态 $\rightarrow$ 用户态**：执行一条 **特权指令** 来 **修改PSW** 的标志位为“用户态”，意味着操作系统将主动让出CPU使用权。
   - **用户态 $\rightarrow$ 内核态**：由 **“中断”** 引发，**硬件自动完成变态过程**，触发中断信号意味着操作系统将强行夺回CPU的使用权。**但凡需要操作系统介入的地方，都会触发中断信号**。
   - **CPU状态转换的过程是有成本的**，要消耗不少时间，**频繁的转换会降低系统性能**。




### （二）中断
1. 中断的 **作用**
**中断** 会使CPU由用户态变为内核态，使操作系统重新夺回对CPU的控制权，是 **让操作系统内核夺回CPU使用权** 的唯一途径。

2. 中断的 **类型**
   1. **内中断（异常/例外）**：与当前执行的指令 **有关**，中断信号来源于CPU **内部**。
   异常可分为：
       - **自陷（陷入）**：由 **陷入指令（trap指令/访管指令）** 引发，是程序故意引发的。该指令会引发一个内部中断信号。
  如：**陷阱指令**（执行“陷入指令”，意味着应用程序主动的将CPU控制权还给操作系统内核。“系统调用”就是通过陷入指令完成的）、**系统调用指令**。
       - **故障**：由错误条件引起的，可能被内核程序修复。内核程序修复故障后会把CPU使用权还给应用程序，让它继续执行下去。
  如：非法操作码、缺页故障、除数为 0、计算溢出。
       - **终止**：由致命错误引起的，内核程序无法修复该错误，因此一般不会再将CPU使用权还给引发终止的应用程序，而是直接终止该应用程序。
  如：控制器出错、存储器校验错等。
  
   2. **外中断（中断）**：与当前执行的指令 **无关**，中断信号来源于CPU **外部**。
   例如：
        - **时钟中断**：由 **时钟部件** 发来的中断信号。时钟部件每隔一个时间片会给CPU发送一个时钟中断信号。
        - **I/O中断**：由输入/输出设备发来的中断信号。

   - **程序性异常（软件中断）**：**故障异常** 和 **自陷异常**。
   - **硬件中断**：**终止异常** 和 **外部中断**。

3. 中断的 **基本原理**
**不同的中断信号，需要用不同的中断处理程序来处理**。当CPU检测到中断信号后，会根据中断信号的类型去查询“**中断向量表**”，以此来找到对应的中断处理程序在内存中的存放位置。
   - **检查中断信号**：
      - **内中断**：CPU在执行指令时会检查是否有异常发生。
      - **外中断**：每个指令周期末尾，CPU都会检查是否有外中断信号需要处理。

   - 中断处理程序一定是 **内核程序**，需要运行在 **“内核态”**。



### （三）系统调用
**系统调用** 是操作系统提供给应用程序（程序员/编程人员）使用的接口，可以理解为一种可供程序调用的特殊函数，**应用程序可以通过系统调用来请求获得操作系统内核的服务**。
  - **系统调用与库函数的区别**：有的库函数是对系统调用的进一步封装；有的没有使用系统调用。

1. 系统调用的 **作用**：系统中的各种共享资源由操作系统内核进行统一管理，并向上提供“系统调用”，用户进程想要使用这种共享资源，只能通过系统调用向操作系统内核发出请求。内核会对各个请求进行协调处理。**凡是与共享资源有关的操作（如存储分配、I/O操作、文件管理），都必须通过系统调用的方式向操作系统内核提供服务请求**，由操作系统内核代为完成。这样 **可以保证系统的稳定性和安全性**，防止用户进行非法操作。

2. 系统调用的 **功能**：
   - **设备管理**：完成设备的 **请求/释放/启动** 等功能。
   - **文件管理**：完成文件的 **读/写/创建/删除** 等功能。
   - **进程控制**：完成进程的 **创建/撤销/阻塞/唤醒** 等功能。
   - **进程通信**：完成进程间的 **消息传递/信号传递** 等功能。
   - **内存管理**：完成内存的 **分配/回收** 等功能。

3. 系统调用的 **过程**
   传递程序调用参数 $\rightarrow$ 执行陷入指令（**用户态**） $\rightarrow$ 由操作系统内核程序处理系统调用请求（**核心态**） $\rightarrow$ 返回应用程序
   *注意*：
   1. **陷入指令** 是在 **用户态** 执行的，执行陷入指令之后立即引发一个 **内中断** ，是CPU **进入核心态**。
   2. **发出系统调用请求** 是在 **用户态**，而 **对系统调用的相应处理** 在 **核心态** 下进行。




## 六、操作系统的结构
### （一）分层结构
内核分多层，每层可单向调用更低一层提供的接口。最底层是硬件，最高层是用户接口。

- **优点**：
  - 便于调试和验证，自底向上逐层调试验证。
  - 易扩充和易维护，各层之间调用接口清晰固定。

- **缺点**：
  - 仅可调用相邻低层，难以合理定义各层的边界。
  - 效率低，不可跨层调用，系统调用执行时间长。



### （二）模块化
将内核划分为多个模块，各模块之间相互协作。整个内核由主模块（最核心的模块）和可加载模块（可动态加载到内核中，而无需重新编译整个内核）组成。

- 衡量模块独立性主要有两个标准：
  - **内聚性**：模块内部各部分之间联系的紧密程度。内聚性越高，模块独立性越好。
  - **耦合度**：模块间相互联系和相互影响的程度。耦合度越低，模块独立性越好。

- **优点**：
  - 模块间逻辑清晰，易于维护，确定模块间接口后即可多模块同时开发，加速了操作系统的开发过程。
  - 支持动态加载新的内核模块（如：安装设备驱动程序、安装新的文件系统模块到内核），增强OS适应性。
  - 任何模块之间都可以直接调用其他模块，无需采用消息传递进行通信，效率高。

- **缺点**：
  - 模块间的接口定义未必合理、实用。
  - 模块间相互依赖，更难调试和验证。



### （三）宏内核（单内核/大内核）
将操作系统的主要功能模块都作为系统内核，运行在核心态。

- **优点**：高性能，内核内部各种功能都可以直接互相调用。

- **缺点**：
  - 内核代码庞大，结构混乱，难以维护。
  - 大内核中某个功能模块出错，就可能导致整个系统崩溃。



### （四）微内核
只把中断、原语、进程通信最基本的功能保留在内核。进程管理、文件管理、设备管理等功能以用户进程的形式运行在用户态。

- **特点**：
  - **扩展性和灵活性**
  - **可靠性和安全性**
  - **可移植性**
  - **分布式计算**

- **优点**：
  - 内核功能少，结构清晰，方便维护。
  - 内核外的某个功能模块出错不会导致整个系统崩溃。

- **缺点**：
  - 需要频繁的在核心态和用户态之间切换，性能低。
  - 用户态下的各功能模块不可以直接相互调用，只能通过内核的“消息传递”来间接通信。



### （五）外核
内核负责进程调度、进程通信等功能，外核负责为用户进程分配未经抽象的硬件资源，且由外核负责保证资源使用安全。

- **优点**：
  - 外核可直接给用户进程分配“不虚拟、不抽象”的硬件资源，使用用户进程可以更灵活的使用硬件资源。
  - 减少了虚拟硬件资源的“映射层”，提升效率。

- **缺点**：
  - 降低了系统的一致性。
  - 使系统变得更复杂。





## 七、操作系统引导（开机过程）

**操作系统引导** 指计算机利用 CPU 运行特定程序，通过程序识别硬盘，识别硬盘分区，识别硬盘分区上的操作系统，最后通过程序启动操作系统，一环扣一环的完成上述过程。

**操作系统的引导过程**：
1. **激活 CPU**：激活的 CPU 读取 ROM 中的 boot 程序，将指令寄存器设置为 BIOS（基本输入/输出系统）的第一条指令，即开始执行 BIOS 的指令。

2. **硬件自检**：BIOS 程序在内存最开始的空间构建中断向量表，接下来的 POST（通电自检）过程要用到中断功能。然后进行通电自检，检查硬件是否出现故障。如有故障，主板会发出不同含义的蜂鸣，启动终止；如无故障，屏幕会显示 CPU、内存、硬盘等信息。

3. **加载带有操作系统的硬盘**：通电自检后，BIOS 开始读取 Boot Sequence （通过 CMOS 里保存的启动顺序，或者通过与用户交互的方式），将控制权交给启动顺序排在第一位的存储设备，然后 CPU 将该存储设备引导扇区的内容加载到内存中。

4. **加载主引导记录（MBR）**：硬盘以特定的标识符区分引导硬盘和非引导硬盘。若发现一个存储设备不是可引导盘，就检查下一个存储设备。如无其他启动设备，就会死机。主引导记录 MBR 的作用是告诉 CPU 去硬盘的哪个主分区去找操作系统。

5. **扫描硬盘分区表，并加载硬盘活动分区**：MBR 包含硬盘分区表，硬盘分区表以特定的标识符区分活动分区和非活动分区。主引导记录扫描硬盘分区表，进而识别含有操作系统的硬盘分区（活动分区）。找到硬盘活动分区后，开始加载硬盘活动分区，将控制权交给活动分区。

6. **加载分区引导记录**：读取活动分区的第一个扇区，这个扇区成为 **分区引导记录（PBR）**，其作用是寻找并激活分区根目录下用于引导操作系统的程序（启动管理器）。

7. **加载启动管理器**：分区引导记录搜索活动分区中的启动管理器，加载启动管理器。

8. **加载操作系统**：将操作系统的初始化程序加载到内存中执行。




## 八、虚拟机
**虚拟机**：使用虚拟化技术，将一台物理机器虚拟化为多台 **虚拟机器（Virtual Machine，VM）** 每个虚拟机器都可以独立运行一个操作系统。

把一台物理机器虚拟化为多台虚拟机器，就需要使用 **虚拟机管理程序（Virtual Machine Monitor，VMM）/虚拟机监控程序（Hyperbisor）**。

1. **第一类虚拟机管理程序**
    - **第一类 VMM** 直接运行在硬件上，能直接控制和分配物理资源。
    - 虚拟机作为用户态的一个进程运行，不允许执行敏感指令。而虚拟机上的操作系统认为自己运行在内核态（实际上不是），称为 **虚拟内核态**。
    - **资源分配方式**：在安装用户操作系统时，VMM 要在原本的硬盘上自行分配存储空间，类似于“外核”的分配方式，分配未经抽象的物理硬件。
    - **性能比第二类 VMM 更好**
    - **可支持的虚拟机数量更多**，不需要和宿主操作系统竞争资源，相同的硬件资源可以支持更多的虚拟机。
    - **虚拟机的可迁移性更差**
    - **运行模式**：**第一类 VMM 运行在最高特权级（Ring 0）**，可以执行**最高特权的指令（支持虚拟化的 CPU 通常分更多指令等级）**。

2. **第二类虚拟机管理程序**
   - **第二类 VMM**，运行在宿主操作系统上，依赖于宿主操作系统为其分配物理资源。
   - **资源分配方式**：客户操作系统拥有自己的虚拟磁盘，该盘实际上时宿主操作系统文件系统中的一个大文件。客户操作系统分配到的内存是虚拟内存。
   - **性能比第一类 VMM 更差**，需要宿主操作系统作为“中介”。
   - **可支持的虚拟机数量更少**，宿主操作系统本身需要使用物理资源，宿主操作系统上运行的其他进程也需要物理资源。
   - **虚拟机的可迁移能力更好**，只需导出虚拟机镜像文件即可迁移到另一台宿主操作系统上，商业化应用更广泛。
   - **运行模式**：**第二类 VMM 部分运行在用户态、部分运行在内核态**。客户操作系统发出的系统调用会被 VMM 截获，并转化为 VMM 对 宿主操作系统的系统调用。