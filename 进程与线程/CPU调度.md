<font size = 9>$$处理机调度$$</font>


# 一、调度的概念

**CPU 调度** 是对 CPU 进行分配，即从就绪队列中按照 **一定的算法（公平、高效的原则）选择** 一个进程并将 CPU 分配给它运行，以实现进程并发地执行。

- **调度程序** 是系统的内核程序。





# 二、调度的层次

**作业调度** 从外存的后备队列中选择一批作业进入内存，为它们建立进程，这些进程被送入就绪队列，**进程调度** 从就绪队列中选出一个进程，并将其状态改为运行态，将 CPU 分配给它。**中级调度** 是为了提高内存的利用率，系统将那些暂时不能运行的进程挂起来。

1. **高级调度（作业调度）**：**按一定的原则从外存的作业后备队列中挑选一个**（或多个），**给它（它们）分配内存**、I/O 设备等必要资源，**并建立相应的进程**，以使它（它们）获得竞争 CPU 的权利。
   - 作业调度就是内存与辅存之间的调度。
   - **每个作业只调入一次，调出一次**。作业调入时会建立 PCB，调出时才撤销 PCB。
   - 调度 **发生位置**：**$外存 \rightarrow 内存$（面向作业）**

2. **中级调度（内存调度）**：**按照某种策略决定将哪个处于挂起状态的进程重新调入内存**。
   - 将暂时不能运行的进程调至外存等待。当它们已具备运行条件且内存有空闲时，由 **中级调度决定将哪些已具备运行条件的挂起进程再重新调入内存**，并修改其状态为就绪态，挂在就绪队列上等待。
   - **挂起状态（挂起态）**：暂时调到外存等待的进程状态。
   - **挂起队列**：被挂起的进程 PCB 组织成的队列。
   - 一个进程可能会被多次调出、调入内存，因此 **中级调度** 发生的 **频率** 比高级调度 **更高**。
   - 调度 **发生位置**：**$外存 \rightarrow 内存$（面向进程）**

3. **低级调度（进程调度/处理机调度）**：**按照某种算法从就绪队列中选取一个进程，将 CPU 分配给它**。
    - 进程调度是操作系统中 **最基本的一种调度**，在各种操作系统中都必须配置这级调度。
    - 进程调度的 **频率很高**，一般几十毫秒一次。
    - 调度 **发生位置**：**$内存 \rightarrow CPU$**






# 三、进程调度的时机

1. **需要进行** 进程调度与切换的情况：
   1. 当前运行的进程 **主动放弃** 处理机。
      - **进程正常终止**。
      - **运行过程中发生异常而终止**。
      - **进程主动请求阻塞**。

   2. 当前运行的进程 **被动放弃** 处理机。
      - **分给进程的时间片用完**。
      - **有更紧急的事需要处理**。
      - **有更高优先级的进程进入就绪队列**。

2. **不能进行** 进程调度与切换的情况：
   1. 在 **处理中断的过程中**。
   2. 进程在 **操作系统内核线程临界区** 中。
        - **临界资源**：一个时间段内只允许一个进程使用的资源。各进程需要 **互斥地** 访问临界资源。
        - **临界区**：访问临界资源的那段代码。
        - **内核程序临界区**：一般是用来访问 **某一种内核数据结构** 的，比如进程的就绪队列（由各就绪进程的 PCB 组成）。
        - **内核程序临界区** 访问的临界资源如果不尽快释放的话，极有可能影响到操作系统内核的其他管理工作。因此 **在访问内核程序临界区** 期间 **不能** 进行 **调度与切换**。
        - **普通临界区** 访问的临界资源不会直接影响操作系统内核的管理工作。因此 **在访问普通临界区** 时 **可以** 进行 **调度与切换**。
   3. 在 **原子操作过程中**（原语）。

3. 调度时机
   - **创建新进程**
   - **进程退出**
   - 运行 **进程阻塞**
   - **I/O 中断** 发生

- 在非抢占式调度策略中，只有运行进程阻塞或退出才触发调度程序工作。
- 在抢占式调度策略中，每个 **时钟中断** 或 k 个时钟中断会触发调度工作。

- 有的系统中，只允许进程主动放弃处理机。
- 有的系统中，进程可以主动放弃处理机，当有更紧急的任务需要处理时，也会强行剥夺处理机。





# 四、进程调度的方式

1. **非剥夺调度方式（非抢占方式）**：只允许进程主动放弃处理机。在运行过程中即便有更紧迫的任务到达，当前进程依然会继续使用处理机，直到该进程终止或主动要求进入阻塞态。
   - 实现简单，系统开销小但无法及时处理紧急任务，只适合于早期的批处理系统。

2. **剥夺调度方式（抢占方式）**：当一个进程正在处理机上执行时，如果有一个更重要或更紧迫的进程需要使用处理机，则立即暂停正在执行的进程，将处理机分配给更重要更紧迫的那个进程。
   - 可以优先处理更紧急的进程，也可用来实现让各进程按时间片轮流执行的功能（通过时钟中断）。适合于分时操作系统、实时操作系统。
   - 提高了系统吞吐率和相应效率。
   - 抢占必须遵循一定的原则，主要有 **优先权**、**短进程优先**、**时间片原则** 等。





# 五、进程调度的切换

**请求调度的事件发生** 后，才可能 **运行调度程序**，调度了新的就绪进程后，才会进行 **进程切换**。

- 进程切换在调度完成后立刻发生，需要完成：
    1. 对原来运行进程各种数据的保存。
    2. 对新的进程各种数据的恢复。
   - 各种数据包括程序计数器、程序状态字、各种数据寄存器等处理机现场信息，这些信息一般保存在进程控制块
  *注意*：**进程切换是有代价的**，因此如果 **过于频繁的** 进行进程的 **调度、切换**，必然会使整个 **系统的效率降低**，使系统大部分时间都花在了进程切换上，而真正用于执行进程的时间减少。

- **进程切换的核心操作** 是 **上下文切换**。
  - **上下文切换** 这个任务是指切换 CPU 到另一个进程需要保存当前进程状态并恢复另一个进程的状态。
  - **进程上下文** 采用进程 PCB 表示，包括 CPU 寄存器的值、进程状态和内存管理信息等。
  - **上下文切换的流程** 如下：
      1. 挂起一个进程，将 CPU 上下文保存到 PCB，包括程序计数器和其他寄存器。
      2. 将进程的 PCB 移入相应的队列。
      3. 选择另一个进程执行，并更新其 PCB。
      4. 恢复新进程的 CPU 上下文。
      5. 跳转到新进程 PCB 中的程序计数器所指向的位置执行。
   - 上下文切换开销较大。
   - 上下文切换只能发生在内核态。
   - **模式切换**：用户态与内核态之间的切换。

- **狭义的进程调度** 是指从就绪队列中 **选中一个要运行的进程**，是一种决策行为。（这个进程可以是刚刚被暂停执行的进程，也可能是 **另一个进程**，后一种情况需要 **进程切换**）

- **广义的进程调度** 包含了选择一个进程和进程切换两个步骤。

- **进程切换** 指一个进程让出处理机，由另一个进程占用处理机的过程，是执行行为。

- 当进程切换时，若系统中没有就绪程序，则会调度 **闲逛程序** 运行。
  - 闲逛程序的优先级最低。
  - 闲逛进程占一个完整的指令周期，并在指令周期后例行检查中断。
  - 闲逛进程能耗低，不需要 CPU 之外的资源，它不会被阻塞。





# 六、调度程序（调度器）

**调度程序** 是用于调度和分派 CPU 的组件。

调度程序由三部分组成：
  - **排队器**：将系统中的所有就绪进程按照一定的策略排成一个或多个队列，以便于调度程序选择。每当有一个进程转变为就绪态时，排队器就将它插入相应的就绪队列。
  - **分派器**：依据调度程序所选的进程，将其从就绪队列中取出，将 CPU 分配给新进程。
  - **上下文切换器**：在对 CPU 进行切换时，会发生两对上下文的切换操作：
    1. 将当前进程的上下文保存到其 PCB 中，再装入分配进程的上下文，以便分派进程运行。
    2. 移出分派进程的上下文，将新选进程的 CPU 现场信息装入 CPU 的各个相应寄存器。





# 七、调度算法的评价指标

1. **CPU 利用率**：CPU “忙碌”的时间占总时间的比例。
   **$$利用率 = {忙碌的时间 \over 总时间}$$**

2. **系统吞吐量**：单位时间内完成作业的数量。
   **$$系统吞吐量 = {总共完成了多少道作业 \over 总共花了多少时间}$$**

3. **周转时间**：从 **作业被提交给系统开始**，到 **作业完成为止** 的这段时间间隔。包括四个部分：
   1. 作业在外存后备队列上等待作业调度（高级调度）的时间。
   2. 进程在就绪队列上等待进程调度（低级调度）的时间。
   3. 进程在 CPU 上执行的时间。
   4. 进程等待 I/O 操作完成的时间。

   **$$（作业）周转时间 = {作业完成时间 - 作业提交时间}$$**
   **$$平均周转时间 = {各个作业周转时间之和 \over 作业数}$$**
   **$$带权周转时间 = {作业周转时间 \over 作业实际运行的时间} = {{作业完成时间 - 作业提交时间} \over 作业实际运行的时间}$$**
   **$$平均带权周转时间 = {各作业带权周转时间之和 \over 作业数}$$**

   - 带权周转时间必然 $\geq$ 1
   - 带权周转时间与周转时间都是越小越好。

4. **等待时间**：进程/作业 **处于等待处理机状态时间之和**，等待时间越长，用户满意度越低。
   - 对于 **进程** 来说，等待时间就是指进程建立后 **等待被服务的时间之和**，在等待 I/O 完成的期间其实进程也是在被服务的，所以不计入等待时间。
    **$$等待时间（纯计算型的进程） = 周转时间 - 运行时间$$**
    **$$等待时间（有计算、I/O操作的进程） =周转时间 - 运行时间 - I/O操作的时间$$**
   - 对于 **作业** 来说，不计要考虑 **建立进程后的等待时间，还要加上作业在外存后备队列中等待的时间**。
   - 一个作业总共需要被 CPU 服务多久，被 I/O 设备服务多久一般是确定不变的，因此调度算法只会影响作业/进程的等待时间。
   - 用 **平均等待时间** 来评价整体性能。


5. **响应时间**：从用户 **提交请求** 到 **首次产生响应** 所用的时间。





# 八、CPU 调度算法

各种调度算法的学习思路：
1. 算法思想
2. 算法规则
3. 用于 作业调度 还是 进程调度
4. 调度方式是 抢占式 还是 非抢占式
5. 优缺点
6. 是否会导致 **饥饿**（某进程/作业长期得不到服务）


## （一）先来先服务（FCFS，First Come First Serve）调度算法

1. **算法思想**：重要从“公平”的角度考虑。

2. **算法规则**：**按照作业/进程到达的先后顺序进行服务**。即等待时间越久的越优先得到服务。

3. **既可用于作业调度，也可用于进程调度**。
   - **用于作业调度** 时，考虑的是 **哪个作业先到达后备队列（在外存中）**；
   - **用于进程调度** 时，考虑的是 **哪个进程先到达就绪队列（在内存中）**。

4. 一般是 **非抢占式** 的算法。

5. **优点**：
   - 公平、算法实现 **简单**。
   - **对长作业有利**。
   - **有利于 CPU 繁忙型作业**。

6. **缺点**：
   - **效率低**。
   - **对短作业不利**。
   - **不利于 I/O 繁忙型作业**。

7. **不会导致饥饿**。




## （二）短作业优先（SJF，Shortest Job First）调度算法

1. **算法思想**：追求最少的平均等待时间，最少的平均周转时间、最少的平均带权周转时间。

2. **算法规则**：最短（要求服务时间最短）的作业/进程优先得到服务。每次调度时选择 **当前已到达** 且 **运行时间最短** 的作业/进程。

3. **既可用于作业调度，也可用于进程调度**。
    - 用于 **进程调度** 时，称为 **短进程优先（SPF，Shortest Process First）算法**。

4. **SJF 和 SPF 是非抢占式** 的算法。但 **也有抢占式的版本** -- **最短剩余时间优先算法（SRTN，Shortest Remaining Time Next）**
   - **最短剩余时间优先** 算法：每当有进程加入，引发 **就绪队列改变时就需要调度**，如果新到达的进程 **剩余时间** 比当前运行的进程剩余时间 **更短**，则由新进程 **抢占** 处理机，当前运行进程重新回到就绪队列。另外，当一个 **进程完成时也需要用该算法进行调度**。

**注意**：
  - 如 **未特别说明**，所提到的“短作业/进程优先算法** **默认** 是 **非抢占式** 的。
  - **短作业优先（SJF）调度算法的平均等待时间、平均周转时间是最优的**。对比非抢占式的 SJF，**抢占式的 SRTN 的指标更优**。

5. **优点**：最短的平均等待时间、平均周转时间。

6. **缺点**：
   - 不公平。**对短作业有利，对长作业不利**。
   - 完全未考虑作业的紧迫程度，不能保证紧迫性作业会被及时处理。
   - 可能产生 **饥饿现象**。
   - 作业/进程的运行时间是由用户提供的，并不一定正确，不一定能做到真正的短作业优先。

7. **会导致饥饿**。如果不断有短作业/进程到来，可能使长作业/进程长时间得不到服务，产生“**饥饿**”现象。如果一直得不到服务，则称为“**饿死**”。




## （三）高响应比优先（HRRN，Highest Response Ratio Next）调度算法

1. **算法思想**：要综合考虑作业/进程的等待时间和要求服务的时间。

2. **算法规则**：在每次调度时，先计算各个作业/进程的 **响应比**，选择 **响应比最高** 的作业/进程为其服务。
    - 只有当前运行的进程 **主动放弃 CPU 时**（正常/异常完成，或主动阻塞），才需要进行调度，调度时 **计算所有就绪进程的响应比，选响应比最高的** 进程上处理机。
    **$$响应比 = {{等待时间 + 要求服务时间} \over 要求服务时间}$$**
    - 响应比 $\geq$ 1

3. **主要用于作业调度，也可以用于进程调度**。

4. **非抢占式** 的算法。只有当前运行的作业/进程主动放弃处理机时，才需要调度，才需要计算响应比。

5. **优点**：
   - **综合考虑了等待时间和运行时间**（要求服务时间）。
   - 等待时间相同时，要求服务时间短的优先（SJF 的优点）
   - 要求服务时间相同时，等待时间长的优先（FCFS 的优点）
   - 对于长作业来说，随着等待时间越来越久，其响应比也会越来越大，从而避免了长作业饥饿的问题。

6. **不会导致饥饿**。


**注意**：**FCFS**、**SJF/SPF**、**HRRN** 主要关心用户的公平性、平均周转时间、平均等待时间等评价系统整体性能的指标，但不关心“响应时间”，也不区分任务的紧急程度。交互性很差，一般适用于 **早期的批处理系统**。




## （四）时间片轮转（RR，Round-Robin）调度算法

1. **算法思想**：公平地、轮流地为各个进程服务，让每个进程在一定时间间隔内都可以得到响应。主要适用于分时系统，更注重“响应时间”。

2. **算法规则**：按照各进程到达就绪队列的顺序，轮流让各个进程执行一个 **时间片**。若进程未在一个时间片内执行完，则剥夺处理机，将进程重新放到就绪队列队尾重新排队。
   - 原进程 **下处理机**，同一时刻 **新进程** 到达，**默认新到达的进程先进入就绪队列**。
   - 如果 **时间片太大**，使得每个进程都可以在一个时间片内就完成，则时间片轮转调度算法退化为 **先来先服务** 调度算法，并且 **会增大进程响应时间**。因此 **时间片不能太大**。
   - 如果 **时间片太小**，会导致 **进程切换过于频繁**，系统会花大量时间来处理进程切换，从而导致实际用于进程执行的时间比例减少。所以 **时间片也不能太小**。

3. **用于进程调度**（只有作业放入内存建立了相应的进程后，才能别分配处理机的时间片）。

4. **抢占式** 的算法。由时钟装置发出 **时钟中断** 来通知 CPU 时间片已到。

5. **优点**：
   - **公平**
   - **响应快**，适用于分时操作系统。

6. **缺点**：
   - 由于高频率的进程切换，因此由 **一定开销**；
   - **不区分任务的紧急程度**。

7. **不会导致饥饿**。




## （五）优先级调度算法

1. **算法思想**：随着计算机的发展，特别是实时操作系统的出现，越来越多的应用场景需要根据任务的紧急程度来决定处理顺序。

2. **算法规则**：每个作业/进程有各自的优先级，调度时选择优先级最高的作业/进程。
   - **非抢占式的优先级调度算法**：每次调度时选择 **当前已到达** 且 **优先级最高** 的进程。当前进程 **主动放弃处理机时** 发生调度。
   - **抢占式的优先级调度算法**：每次调度时选择 **当前已到达** 且 **优先级最高** 的进程。当前进程 **主动放弃处理机时** 发生调度。另外，当 **就绪队列发生改变时** 也需要检查是否会发生抢占。
   - 可以按照不同优先级组织多个就绪队列。也可以把优先级高的进程排在更靠近队头的位置。
   - 根据优先级是否可以动态改变，可将优先级分为 **静态优先级** 和 **动态优先级** 两种。
     - **静态优先级**：创建进程时确定，之后一直不变。
     - **动态优先级**：创建进程时有一个初始值，之后会根据情况动态地调整优先级。
     - 通常
       - 系统进程优先级 **高于** 用户进程
       - 前台进程优先级 **高于** 后台进程（交互型进程 **高于** 非交互型进程）
       - 操作系统更 **偏好 I/O 型进程（I/O 繁忙型进程）**。让 I/O 设备尽早运行，与 CPU **并行** 工作，提升资源利用率，系统吞吐量。
         *注意*：与 I/O 型进程相对的是 **计算型进程（CPU 繁忙型进程）**。

3. **既可用于作业调度，也可以用于进程调度**。还会用于 I/O 调度中。

4. **既有抢占式也有非抢占式**。
   - **非抢占式**：只需在进程主动放弃处理机时进行调度即可。
   - **抢占式**：还需在就绪队列发生变化时，检查是否会发生抢占。

5. **优点**：
   - 用优先级区分紧急程度、重要程度，适用于实时操作系统。
   - 可灵活地调整对各种作业/进程的偏好程度。

6. **缺点**：若源源不断地有高优先级的进程到来，则可能导致饥饿。

7. **会导致饥饿**。




## （六）多级反馈队列调度算法

1. **算法思想**：对 FCFS 调度算法、SJF 调度算法、RR 调度算法、优先级调度算法的折中权衡。

2. **算法规则**：
   1. 设置多级就绪队列，各级队列 **优先级** 从 **高到底**，**时间片** 从 **小到大**。
   2. **新进程** 到达时 **先进入第 1 级** 队列，按 **FCFS 原则** 排队等待被分配的时间片。若用完时间片进程还 **未结束**，则进程 **进入下一级** 队列队尾。如果此时 **已经在最下级** 的队列，则 **重新放回** 最下级队列队尾。
   3. 只有第 **k 级队列为空** 时，才会 **为 k + 1  级** 队头的进程 **分配时间片**。
   4. **被抢占处理机的** 进程重新 **放回原队列** 队尾。

3. **用于进程调度**

4. **抢占式** 的算法。在 k 级队列的进程运行过程中，若更上级的队列（1 ~ k-1级）中进入了一个新进程，则由于新进程处于优先级更高的队列中，因此新进程会抢占处理机，原来运行的进程放回 k 级队列队尾。

5. **优点**：
   - 对各类型进程相对公平。（FCFS 的优点）
   - 每个新到达的进程都可以很快就得到响应。（RR 的优点）
   - 短进程只用较少的时间就可以完成。（SPF 的优点）
   - 不必估计进程的运行时间。（避免用户作假）
   - 可灵活地调整对各类进程的偏好程度。

6. **会导致饥饿**。


**注意**：**RR** 调度算法、**优先级调度算法**、**多级反馈队列调度算法** 更注重于系统的响应时间、公平性、平衡性等指标，更适合与 **交互式操作系统**。




## （七）多级队列调度算法

**多级队列调度算法** 在系统中按进程类型设置多个就绪队列，进程创建成功后插入某个队列。

- 每个队列可以采用不同的调度策略。

- 同一队列中的进程可以设置不同的优先级。

- 队列之间可以采取固定优先级，或时间片划分：
  - **固定优先级**：高优先级队列为空时，低优先级进程才能被调度。
  - **时间片划分**：不同的队列划分不同时间片大小。




## （八）基于公平原则的调度算法

1. **保证调度算法**

2. **公平分享调度算法**





# 九、多处理机调度

1. 多处理机调度 **需要处理的问题**：
   1. 考虑让哪个就绪进程优先上处理机。（单处理机调度只需处理这一个问题）
   2. **还需考虑上哪个处理机运行**。

2. 多处理机调度中，**应追求的目标**：
   - **负载均衡**：尽可能让每个 CPU 同等忙碌。
   - **处理机亲和性**：尽量让一个进程调度到同一个 CPU 上运行，以发挥 CPU 中缓存的作用（Cache）。

3. 多处理机 **调度方案**：
   1. **方案一：公共就绪队列**
      - 所有 CPU 共享同一个就绪进程队列。（位于内核区）
      - 每个 CPU 空闲时都会运行调度程序（调度算法与单处理机相同），从公共就绪队列中选择一个进程运行。
      - 每个 CPU 访问公共就绪队列时需要上锁。（确保互斥）
      - **优点**：可以 **天然地实现负载均衡**。
      - **缺点**：各个进程频繁地切换 CPU 运行，**”亲和性”不好**。
      - **提升处理机亲和性** 的方式：
        - **软亲和**：由进程调度程序尽量保证“亲和性”。
        - **硬亲和**：由用户进程通过系统调用，主动要求操作系统分配固定的 CPU，确保“亲和性”。
   2. **方案二：私有就绪队列**
      - 每个 CPU 都有一个私有就绪队列。
      - 每个 CPU 空闲时都会运行调度程序，从私有就绪队列中选择一个进程运行。
      - **实现负载均衡** 的方式：
        - **推迁移（Push）策略**：**一个特定的系统程序周期性检查每个处理器的负载**，如果负载不均衡，就从忙碌 CPU 的就绪队列中“推”一些就绪进程到空闲 CPU 的就绪队列。
        - **拉迁移（Pull）策略**：每个 CPU 运行调度程序时，周期性检查自身负载与其他 CPU 负载。如果一个 CPU 负载很低，就从其他高负载 CPU 的就绪队列中“拉”一些就绪进程到自己的就绪队列。
      - **私有就绪队列天然地实现了“处理机亲和性”**。（也可采用系统调用的方式保证硬亲和）