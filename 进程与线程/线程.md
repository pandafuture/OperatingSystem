<font size = 9>$$线程$$</font>


# 一、线程的概念

**线程（Threads）** 是 “轻量级进程”，是一个 **基本的 CPU 执行单位**，也是 **程序执行流的最小单位**。

- 引入线程的 **目的** 是减小程序在并发执行时所付出的时空开销，提高操作系统的并发性能。
  - 传统的进程间并发，需要切换进程的运行环境，系统开销很大。
  - 线程间并发，如果是同一进程内的线程切换，则不需要切换进程环境，系统开销小。
  - 引入线程后，并发所带来的系统开销减小。

- 引入线程后，不仅是进程之间可以并发，进程内的 **各线程之间** 也可以 **并发**，从而进一步 **提升了系统的并发度**，使得一个进程内也可以并发处理各种任务。

- 引入线程后，**进程** 只作为 **除 CPU 之外的系统资源分配单元**（各种资源都是分配给进程的，而不是线程）。原本线程是资源分配、调度的基本单位。引入线程后，线程是调度的基本单位。





# 二、线程的属性
1. 线程是处理机调度的单位。
2. 多 CPU 计算机中，各个线程可占用不同的 CPU。
3. 每个线程都有一个线程 ID、程序控制块（TCB）。（TCB 记录线程执行的寄存器和栈等现场状态）
4. 不同的线程可以执行相同的程序，即同一个服务程序被不同用户调用时，操作系统会把它们创建成不同的线程。
5. 线程也有就绪、阻塞、运行三种基本状态。
6. 线程几乎不拥有系统资源。
7. 同一进程的不同线程间共享该进程所拥有的资源。
8. 由于共享内存地址空间，同一进程中的线程间通信无需系统干预。
9. 同一进程中的线程切换，不会引起进程切换。
10. 不同进程中的线程切换，会引起进程切换。
11. 切换同进程内的线程，系统开销很小。切换进程，系统开销较大。





# 三、线程的实现方式

线程的实现方式有两种：**用户级线程（ULT）** 和 **内核级线程（KLT，又称内核支持的线程）**。


## （一）用户级线程（ULT）

**“用户级线程”** 就是 **“从用户视角能看到的线程”**。

1. 用户级线程由应用程序 **通过线程库实现**，所有的 **线程管理工作** 都由 **应用程序负责**（包括线程创建、撤销和切换等）。
2. 用户级线程中，**线程切换** 可以在 **用户态下即可完成**，无需操作系统干预。
3. 在用户看来，是有多个线程。但是在操作系统内核看来，并意识不到线程的存在。
4. 设置了用户级线程的系统，其调度仍然以进程为单位。

- **优点**：
  - 用户级线程的切换在用户空间即可完成，不需要切换到核心态，节省了模式切换的开销，线程管理的系统开销小，效率高。
  - 调度算法可以是进程专用的，不同的进程可根据自身的需要，对自己的线程选择不同的调度算法。
  - 用户级线程的实现与操作平台无关，对线程管理的代码是属于用户程序的一部分。

- **缺点**：
  - 当一个用户级线程被阻塞后，整个进程都会被阻塞，并发度不高。
  - 不能发挥多 CPU 的优势，多个线程不可在多核处理机上并行运行。




## （二）内核级线程（KLT）

**“内核级线程”** 就是 **“从操作系统内核视角看能看到的线程”**。

1. **内核级线程的管理工作** 由 **操作系统内核** 完成。**内核级线程才是处理机分配的单位**。
2. 线程调度、切换等工作都由内核负责，因此 **内核级线程的切换** 必然需要在 **核心态** 下才能完成。
3. 操作系统会为每个内核级线程建立相应的 **线程控制块（TCB）**，通过 TCB 对线程进行管理。

- **优点**：
  - 能发挥多 CPU 的优势，多个线程可在多核处理机上并行执行。
  - 当一个线程被阻塞后，别的线程还可以继续执行，并发能力强。
  - 内核支持线程具有很小的数据结构和堆栈，线程切换比较快、开销小。
  - 内核本身也可采用多线程技术，提高系统的执行速度和效率。

- **缺点**：一个用户进程会占用多个内核级线程，线程切换由操作系统内核完成，需要切换到核心态，因此线程管理的成本高，开销大。




## （三）组合方式
上述两种方式的结合。





# 四、多线程模型
在同时支持用户级线程和内核级线程的系统中，**根据用户级线程和内核级线程的连接方式不同**，可以形成三种 **多线程模型**。

## （一）一对一模型
**一对一模型** 将 **每个用户级线程映射到一个内核级线程**。每个进程有与用户级线程数量相同的内核级线程。线程切换由内核完成，需要切换到内核态。

- **优点**：
  - **当一个线程被阻塞后，别的线程还可以继续执行，并发能力强**。
  - **多线程可在多核处理机上并行执行**。

- **缺点**：每创建一个用户级线程，就要创建一个内核级线程，一个用户进程会占用多个内核级线程，**线程切换由操作系统内核完成**，需要切换到核心态，**线程管理的成本高，开销大**。




## （二）多对一模型

**多对一模型** 将 **多个用户级线程映射到一个内核级线程**。每个进程只被分配一个内核级线程。线程的调度和管理在用户空间完成。

- **优点**：线程管理是在用户空间进行的，无需切换到内核态，**线程管理的系统开销小**，效率高。

- **缺点**：
  - **当一个用户级线程被阻塞后，整个整个进程都会被阻塞，并发度不高**。
  - 在任何时刻，只有一个线程能够访问内核，多个线程不能同时在多个 CPU 上运行。

*注意*：操作系统只“看得见”内核级线程，因此只有 **内核级线程才是处理机分配的单位**。




## （三）多对多模型

**多对多模型** 将 **n 个用户级线程映射到 m 个内核级线程上**，要求 **$n \geq m$**。每个用户进程对应 m 个内核级线程。

- **特点**：
  - 克服了多对一模型并发度不高的缺点（一个阻塞全体阻塞）。
  - 克服了一对一模型中一个用户进程占用太多内核级线程，开销太大的缺点。
  - **拥有一对一模型和多对一模型各自的优点**。

- **内核级线程才是处理机分配的单位**。

- 内核级线程中可以运行任意一个由映射关系的用户级线程代码，只有当该进程被分配的内核级线程中正在运行的代码逻辑都阻塞时，这个进程才会阻塞。





# 五、线程的状态与转换

线程在运行时具有三种 **基本状态**：
- **执行态**：线程已获得 CPU 而正在运行。
- **就绪态**：线程已具备各种执行条件，只需再获得 CPU 便可立即执行。
- **阻塞态**：线程在执行中因某事件受阻而处于暂停暂停。

```mermaid
flowchart LR;
    A([就绪态]);
    B([执行态]);
    C([阻塞态]);

    A ===>|被调度程序选中| B
    B ===>|时间片用完| A
    B ===>|等待某事件| C
    C ===>|等待的事件发生| A

    linkStyle 0,1,2,3 stroke:white,stroke-width:4px,color:
```






# 六、线程的组织与控制

每个线程配置一个 **线程控制块（TCB）**，用于记录控制和管理线程的信息。

- **TCB 包括**：
  - **线程标识符 TID**
  - **一组寄存器**
    - **程序计数器 PC**：记录线程目前执行到哪里。
    - **状态寄存器**
    - **通用寄存器**
  - **堆栈指针**：保存函数调用信息、局部变量等。
  - **线程运行状态**：描述线程正处于何种状态。
  - **优先级**：线程调度，资源分配的参考。
  - **线程专有存储区**：线程切换时用于保存现场等。

- 多个线程的 TCB 可组织起来，成为一张 **线程表**。

- 同一进程中的所有线程都能访问进程的地址空间和全局变量。但是，每个线程都拥有自己的堆栈，且互不共享。