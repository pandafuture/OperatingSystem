<font size = 9>$$文件管理$$</font>



# 一、文件的定义

**文件（File）** 是以硬盘为载体的存储在计算机上的信息集合，文件可以是文本文档、图片、程序等。

**数据项**：文件系统中最低级的数据组织形式。有两种类型：
  1.  **基本数据项**：用于描述一个对象的某种属性的一个值。是数据中的最小逻辑单位。
  2.  **组合数据项**：由多个基本数据项组成。

**记录**：是一组相关数据项的集合，用于描述一个对象在某方面的属性。

**文件系统** 是操作系统提供的用于实现用户对文件的维护管理的文件管理系统。

- 系统运行时，计算机 **以进程为基本单位** 进行 **资源的调度和分配**。

- 在用户 **进行输入、输出中**，则 **以文件为基本单位**。

- 文件可以长期存储在硬盘中，允许可控制的进程间共享访问，能够被组织成复杂的结构。

- 文件的基本访问单元可以是字节或记录。






# 二、文件的属性

**文件属性（文件元数据）** 包括：
1. **名称**：由创建文件的用户决定文件名，主要是为了方便用户找到文件，**同一目录下不允许有重名文件**。
2. **标识符**：一个系统内的各文件标识符唯一，对用户来说毫无可读性，因此标识符只是操作系统用于区分各个文件的一种内部名称。
3. **类型**：指明文件的类型。
4.  **创建者**：文件创建者的 ID。
5.  **所有者**：文件当前所有者的 ID。
6. **位置**：文件存放的路径（让用户使用）、在外存中的地址（操作系统使用，对用户不可见）。
7. **大小**：文件当前大小（用字节、字或块表示），也可包含文件允许的最大值。
8.  **保护**：对文件进行保护的访问控制信息。
9. **创建时间**：文件创建的时间。用于保护和跟踪文件的使用。
10. **最后一次修改时间**：上次修改的时间。用于保护和跟踪文件的使用。
11. **最后一次存取时间**：上次访问的时间。用于保护和跟踪文件的使用。





# 三、文件的逻辑结构

文件的 **逻辑结构** 指从用户角度出发所看到的文件的组织形式。即，在文件的内部，数据在逻辑上是如何组织起来的。

按 **逻辑结构**，文件可划分为 **无结构文件** 和 **有结构文件**。

## （一）无结构文件
**无结构文件（流式文件）** 是最简单的文件组织形式，它是 **由一系列二进制流或字符流构成** 的文件，其长度以字节为单位。没有明显的逻辑结构。

## （二）有结构文件
**有结构文件（记录式文件）** 指有一个以上的 **记录构成** 的文件。各记录由相同或不同数量的数据项组成。
   - **记录** 是一组相关数据项的集合。每条记录有一个数据项可作为 **关键字**。
     - 根据各条记录的长度（占用的存储空间）是否相等，又可分为 **定长记录** 和 **变长记录**。
   - **数据项** 是文件系统中最基本的数据单位。

有结构文件按照 **记录的组织形式** 可分为 **顺序文件**、**索引文件**、**索引顺序文件**。

### 1. 顺序文件
**顺序文件** 中的记录一个接一个地顺序排列（逻辑上），记录可以是 **定长记录** 或 **变长记录**。各个记录在物理上可以 **顺序存储** 或 **链式存储**（一般默认是顺序存储）。

- 根据顺序文件中 **记录的排序** 又可分为两种结构：
  - **串结构**：**记录之间的顺序与关键字无关**。通常按照记录存入的时间决定记录的顺序。
  - **顺序结构**：**记录之间的顺序按关键字顺序排列**。

- 顺序文件采用 **链式存储** 时，无论是定长/变长记录，**都无法实现随机存取**，每次只能从第一个记录开始依次往后查找。

- 顺序存储采用 **顺序存储**，
  - 记录为 **变长记录** 时，**无法实现随机存取**。每次只能从第一个记录开始依次往后查找。
  - 记录为 **定长记录** 时，
     - **可实现随机存储**。记录长度为 L，则第 i 个记录存放的相对位置时 $i * L$。
     - 若采用 **串结构**，**无法快速找到某关键字对应的记录**。
     - 若采用 **顺序结构**，**可以快速找到某关键字对应的记录**（如折半查找）

- 含有 $N$ 条记录的顺序文件，查找某关键字的记录时，平均需要查找 $N \over2$ 次。

- **优点**：对记录进行批量操作时，**顺序文件的效率是所有逻辑文件中最高的**。
  - 对于顺序存储设备（如磁带），只有顺序文件才能被存储并能有效工作。

- **缺点**：**查找、修改、增加、删除一个记录时比较困难，性能较差**。



### 2. 索引文件
**索引文件** 在 **顺序文件** 的基础上建立一张 **索引表**，为主文件中的每个记录设置一个 **索引表项**，其中包括 **指向记录的指针** 和 **记录长度**。
  - 索引表：

    |索引号|长度 m|指针 ptr|
    |:---:|:----:|:------:|

  - **索引表** 本身是 **定长记录的顺序文件**。因此可以快速找到第 i 个记录对应的索引项。
  - 可将关键字作为索引号内容，若按关键字顺序排列，则可以支持按照关键字折半查找。
  - 每当要增加/删除一个记录时，需要对索引表进行修改。
  - 索引文件由很快的检索速度，所以 **主要用于对信息处理的及时性要求比较高的场合**。
  - **可以用不同的数据项建立多个索引表**。
  - **优点**：检索速度块。
  - **缺点**：增加了存储开销。索引文件需要配置索引表，且每个记录都要有一个索引项。



### 3. 索引顺序文件
**索引顺序文件** 是索引文件和顺序文件思想的结合。

- 最简单的索引顺序表（只使用一级索引）：
  1.  先将变长记录顺序文件中的所有记录分为若干组
  2.  然后为文件建立一张索引表
  3.  为每组中的第一个记录建立一个索引项，其中包含该记录的关键字和指向该记录的指针。即，并不是每个记录对应一个索引表项，而是 **一组记录对应一个索引表项**。
  - 索引项不需要按照关键字顺序排列，可以极大地方便新表项的插入。

- 记录过多时，为了进一步提高检索效率，可以为顺序文件建立 **多级索引表**。

- 假设 $N$ 条记录分为 $\sqrt{N}$ 组，索引表中有 $\sqrt{N}$ 个表项，每组有 $\sqrt{N}$ 条记录，在查找某关键字时：
  - 先顺序查找索引表，需要查找 $\sqrt{N} \over 2$ 次。
  - 然后在主文件对应的组中顺序查找，需要查找 $\sqrt{N} \over 2$ 次。
  - 所以共需要查找 ${\sqrt{N} \over 2} + {\sqrt{N} \over 2} = \sqrt{N}$ 次。

- **优点**：提高了查找效率。

- **缺点**：因配置索引表而增加了存储空间。



### 4. 直接文件（散列文件，Hash File）
散列文件中，给定记录的键值或通过散列函数转换的键值直接决定记录的物理地址。

- 优点：散列文件具有很高的存取速度。

- 缺点：会引起冲突。即，不同关键字的散列函数值可能相同。





# 四、文件的物理结构（文件分配方式）

文件的 **物理结构（存储结构）** 指将文件存储在外存上的存储组织形式，是用户所看不见的。
- **文件的物理结构** 就是文件的实现，文件数据在物理存储设备上是如何分布和组织的。从两方面实现：
  - **文件的分配方式**：对磁盘非空闲块的管理。
  - **文件存储空间管理**：对磁盘空闲块的管理。

- **磁盘块**：磁盘中的存储单元被分为一个个的块，**大小通常与内存的内存块、页面的大小相同**。每块一般包含 2 的整数幂个地址。

- 在外存管理中，为了方便对文件数据的管理，**文件的逻辑地址空间被分为了一个一个的文件“块”**。
  - 文件的 **逻辑地址** 表示为 **（逻辑块号，块内地址）** 的形式。

- **操作系统以块为单位为文件分配存储空间**。

- 用户通过逻辑地址来操作自己的文件，操作系统要负责实现从逻辑地址到物理地址的映射。

- 内存与磁盘之间的数据交换（磁盘 I/O）都是以块为单位进行的。

- 每个存储单元对应一个物理地址：（物理块号，块内地址）。块内地址的位数取决于磁盘块的大小。


## （一）连续分配

**连续分配** 方式要求 **每个文件在磁盘上占有一组连续的块**。

- 一个文件的 **目录项** 应该记录该文件的 **第一个磁盘块的块号（起始块号）** 和 **长度（所占用的块数）**。

- 用户给出要访问的逻辑块号，操作系统找到该文件对应的目录项（FCB），通过 $物理块号 = 起始块号 + 逻辑块号$ 得到物理块号。
  - 操作系统要检查用户提供的逻辑块号是否合法（$逻辑块号 \geq 长度$ 就不合法）。

- **优点**：
  - 支持 **顺序访问和直接访问（即随机访问）**。因为可以直接算出逻辑块号对应的物理块号。
  - **文件在顺序读/写时速度最快**。文件所占用的块可能位于一条或几条相邻的磁道上，磁头的移动距离最小。

- **缺点**：
  - 物理上采用 **连续分配的文件不方便拓展**。
  - 物理上采用 **连续分配，存储空间利用率低，会产生难以利用的磁盘碎片（外部碎片）**。
    - 可以用 **紧凑** 来处理碎片，但是需要耗费很大的时间代价。
  - 为保持文件的有序性，删除和插入记录时，需要对相邻的记录做物理上的移动。




## （二）链接分配

**链接分配** 采取 **离散分配** 的方式，可以为文件分配离散的磁盘块。

链接分配可以分为 **隐式链接** 和 **显式链接** 两种形式。

- 若未指明，**默认** 是 **隐式链接** 的链接分配。

### 1. 隐式链接

隐式链接中的 **目录项** 还包含了 **文件第一块的指针（盘块号）（起始块号）** 和 **最后一块的指针（结束块号）**。

- 除文件的最后一个盘块外，每个盘块都存有指向下一个盘块的指针，这些指针对用户是透明的。

- **实现文件的逻辑块号到物理块号的转变**。即，用户给出要访问的逻辑块号 i，操作系统找到该文件对应的目录项（FCB）：
  - 从目录项中找到起始块号（即 0 号块），将 0 号逻辑块读入内存，由此知道 1 号逻辑块存放的物理块号，于是读入 1 号逻辑块，在找到 2 号逻辑块的存放位置......以此类推。
  - 读入 i 号逻辑块，总共需要 $i + 1$ 次磁盘 I/O

- **优点**：
  - **很方便文件拓展**
  - **不会有碎片问题，外存利用率高**。所有的空闲磁盘块都可以被利用。

- **缺点**：
  - 只支持顺序访问，不支持随机访问，要访问文件的第 i 块，则只能从第 1 块开始，通过盘块指针顺时针查找到第 i 块，查找效率低。
  - 指向下一个盘块的指针也要耗费一定的存储空间。
  - 稳定性问题。文件盘块中的任何一个指针出现问题，都会导致文件数据的丢失。



### 2. 显式链接

**显式链接** 将用于链接文件各物理块的指针，显式地存放在内存的一张链接表（**文件分配表**）中。

- **文件分配表（FAT，FileAllocation Table）** 在 **整个文件系统中仅设置一张**。

    |物理块号（盘块号）|下一块|
    |:--------------:|:----:|

- FAT 的表项与全部磁盘块一一对应，并且可以用一个特殊的数字 -1 表示文件的最后一块，可以用 -2 表示整个磁盘块是空闲的。

- **开机时，将 FAT 读入内存，并常驻内存**。

- FAT 的各个表项在物理上连续存储，且每一个表项长度相同，因此“物理块号”字段可以时隐含的。

- 文件目录中只需记录该文件的起始块号。后续块号可以通过差 FAT 找到。

- 实现文件的逻辑块号到物理块号的转变。即，用户给出要访问的逻辑块号 i，操作系统找到该文件对应的目录项（FCB）：
  - 从目录项中找到起始块号
  - 若 $i > 0$，则查询内存中的文件分配表 FAT，往后找到 i 号逻辑块对应的物理块号。
  - **逻辑块号转换成物理块号的过程不需要读磁盘操作**。

- **优点**：
  - 支持顺序访问，也 **支持随机访问，要访问第 i 块，无需依次访问前 i - 1 块**。
  - 由于块号转换的过程不需要访问磁盘，因此相比于隐式链接来说，**访问速度快很多，访问效率更高**。
  - **不会产生外部碎片**。
  - **可以很方便地对文件进行拓展**。

- **缺点**：FAT 需要占用一定的存储空间。




## （三）索引分配

### 1. 单极索引分配方式

**索引分配** 允许文件离散地分配在各个磁盘块中，系统会 **为每个文件建立一张索引表**，索引表中 **记录了文件的各个逻辑块对应的物理块**。

|逻辑块号|物理块号|
|:-----:|:------:|

- **索引块**：索引表存放的磁盘块。

- **数据块**：文件数据存放的磁盘块。

- 在文件目录中需要记录文件的索引块时第几号磁盘块。

- 可以用固定的长度表示物理块号。因此，索引表中的“逻辑块号”可以是隐含 。

- 实现文件的逻辑块号到物理块号的转变。即，用户给出要访问的逻辑块号 i，操作系统找到该文件对应的目录项（FCB）：
  - 从目录项中可知索引表存放位置，将索引表从外存读入内存
  - 查找索引表即可知 i 号逻辑块在外存中的存放位置。

- **优点**：
  - **支持随机访问**。当要访问第 i 块时，索引块的第 i 个条目指向的便是文件的第 i 个块。
  - **不会产生外部碎片**。
  - **容易实现文件拓展**。只需给文件分配一个空闲块，并增加一个索引表项即可。

- **缺点**：**索引表需要占用一定的存储空间**。

- **索引块的问题**：
  - 每个文件必须由一个索引块，当文件很小时，比如只有数个盘块，该方式任为之分配一个索引块，此时索引块的利用率很低。
  - 当文件很大时，若其盘块号都需要占用若干个索引块。
    - 此时可以通过 **链接方案** 即链指针将各索引块按序链接起来，但这种方法是低效的。
    - 若想要访问文件的最后一个逻辑块，就必须找到最后一个索引块，而这需要先顺序地读入前面的所有索引块。
    - 那还可以采用 **多级索引方案** 或 **混合索引方案**。



### 2. 多级索引分配方式

**多级索引**：**建立多次索引**。使第一层索引块指向第二层索引块。还可根据文件大小的要求再建立第三层、第四层索引块。

- **主索引**：一级索引。

- 若采用多次索引，则 **各层索引表大小不能超过一个磁盘块**。

- 采用 K 层索引结构，且 **顶级索引表未调入内存**，则访问一个数据块只需要 $K + 1$ 次读磁盘操作。

- **优点**：极大加快了对大型文件的查找速度。

- **缺点**：当访问一个盘块时，其所需启动磁盘的次数随着索引级数的增加而增多，即使是对数量众多的小文件也是如此。



### 3. 混合索引分配方式

**混合索引**：多种索引分配方式的结合。

- **直接地址索引（直接寻址）**：直接指向 **数据块**。

- **一级间接索引（一次间址）**：指向 **单层索引表**。

- **二级间接索引（两级索引分配）**：指向 **两层索引表**。

- **优点**：对于小文件来说，访问一个数据块所需的读磁盘数更少。


**注意**：
  - 要会根据多次索引、混合索引的结构计算出文件的最大长度。（Key：各级索引表最大不能超过一个块）
  - 分析访问某个数据块所需要的读磁盘次数。（要注意顶级索引块是否已调入内存）





# 五、 文件存储空间管理

**文件存储设备的管理** 实质上是 **对空闲块的组织和管理**。包括空闲块的组织、分配与回收等问题。

**存储空间的划分**：将物理磁盘划分为一个个文件卷（逻辑卷、逻辑盘）。

- **卷**：包含系统文件的分区。

**存储空间的初始化**：将各个文件卷划分为目录区、文件区。

- **目录区**：主要存放文件目录信息（FCB）、空闲表、位示图、超级块等用于用户磁盘存储空间管理的信息。

- **文件区**：用于存放文件数据。

- 有的系统支持超大型文件，可支持由多个物理磁盘组成的一个文件卷。

- 文件存储设备分成许多大小相同的 **物理块**，并以 **块** 为单位交换信息。

**磁盘空闲块管理的方法** 有四种：**空闲表法**、**空闲链表法**、**位示图法**、**成组链接法**。


## （一）空闲表法

**空闲表法** 属于 **连续分配方式**。会为每个文件 **分配一块连续的存储空间**。

系统为外存上所有的空闲区建立一张 **空闲表**，每个空闲区对应一个 **空闲表项**。再将所有空闲区按其其实盘块号递增的次序排列。

|序号|第一个空闲盘块号|空闲盘块数|
|:--:|:------------:|:-------:|

- **空闲表项** 包括：**表项序号**、**该空闲区的第一个空闲盘块号**、**该空闲区的空闲盘块数** 等信息。

1. **盘块的分配**
与内存管理中的动态分区分配很类似，为一个文件分配连续的存储空间。同样 **可采用首次适应、最佳适应、最坏适应等算法** 来决定要为文件分配哪个区间。

2. **盘块的回收**
要考虑 **回收区是否与空闲盘块表中插入点的前区和后区相邻接，对相邻接者应予以合并**。
   - 回收区的前后都没有相邻空闲区。
   - 回收区的前后都是空闲区。
   - 回收区前面是空闲区。
   - 回收区后面是空闲区。

- **优点**：
  - 有较高的分配速度。
  - 可减少访问磁盘的 I/O 频率。

- **缺点**：不适用于大型文件系统。因为空闲表可能过大。




## （二）空闲链表法

**空闲链表法** 是将所有空闲盘区拉成一条空闲链。

- 空闲链表法分为两种方式实现：
  - **空闲盘块链**：以 **盘块** 为单位组成一条空闲链。
  - **空闲盘区链**：以 **盘区** 为单位组成一条空闲链。

### 1. 空闲盘块链
**空闲盘块链** 是指将磁盘上的所有空闲空间以盘块为单位拉成一条链。

- 每个盘块中存储着指向下一个空闲盘块的指针。

- 操作系统保存着 **链头、链尾指针**。

1. **盘块的分配**
若某文件申请 K 个盘块，则从链头开始一次摘下 K 个盘块分配，并修改空闲链的链头指针。

2. **盘块的回收**
回收的盘块依次挂到链尾，并修改空闲链的链尾指针。

- **优点**：
  - 适用于离散分配的物理结构。
  - 分配和回收一个盘块的过程非常简单。

- **缺点**：
  - 为一个文件分配盘块时可能要重复多次操作，效率较低。
  - 因为是以盘块为单位的，空闲盘块链会很长。



### 2. 空闲盘区链
**空闲盘区链** 是指将磁盘上的所有空闲盘区拉成一条链，每个盘区包含若干相邻的盘块。

- 每个盘区含有指向下一个空闲盘区的指针和本盘区的盘块数。

- 操作系统保存着 **链头、链尾指针**。

1. **盘块的分配**
若某文件申请 K 个盘块，则可以采用首次适应（通常使用的）、最佳适应等算法，从链头开始检索，按照算法规则找到一个大小符合要求的空闲盘区，分配给文件。
若没有合适的连续空闲块，也可以将不同盘区的盘块同时分配给一个文件，注意分配后可能要修改相应的链指针、盘区大小等数据。

2. **盘块的回收**
要将回收区与相邻接的空闲盘区合并。
   - 若回收区与某个空闲盘区相邻，则需将回收区合并到空闲盘区中。
   - 若回收区没有和任何空闲区相邻，将回收区作为单独的一个空闲盘区挂到链尾。

- **优点**：
  - 离散分配、连续分配都适用。
  - 为一个文件分配多个盘块时效率更高。且空闲盘区链较短。

- **缺点**：分配与回收的过程比较复杂。



## （三）位示图法

**位示图**：每个二进制位对应一个盘块。利用二进制的一位表示磁盘中一个盘块的使用情况，磁盘上的所有盘块都有一个二进制位与之对应。

- 例如：一个字的字长为 16 位，字中的每一位对应一个盘块。
  - **用（字号/行号，位号/列号）对应一个盘块号**

  |字号\位号 |0|1|2|3|4|5|...|16|
  |:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-|
  |**0**|0|1|0|1|1|1|...|1|
  |**1**|1|1|1|0|1|0|...|1|
  |**2**|1|0|1|1|1|0|...|0|
  |**...**|0|0|0|0|1|1|...|1|
  |**16**|1|1|1|1|0|0|...|0|

- 其值为 0 时，表示对应的盘块空闲。
- 其值为 1 时，表示对应的盘块已分配。
- 一个 $m \times n$ 位组成的位示图就可以用来表示 $m \times n$ 个盘块的使用情况。

- 若 n 表示字长，**盘块号、字号、位号从 0 开始**，
  - 则 $(字号，位号) = (i,j)$ 对应的 盘块号为 **$盘块号b = 字长n \times 字号i + 字位j$**
  - b 号盘块对应的 **$字号i = 盘块号b / 字长n$**；**$位号 = 盘块号b \% 字长n$**

*注意*：注意条件中的 **盘块号、字号、位号** 是从 0 开始还是从 1 开始。

1. **盘块的分配**
若文件需要 K 个块，
   1. 顺序扫描位示图，找到 K 个相邻或不相邻的 “0”；
   2. 根据字号、位号算出对应的盘块号，将相应盘块分配给文件；
   3. 修改位示图，将相应位置设为 “1”。

2. **盘块的会回收**
   1. 根据回收的盘块号计算出对应的字号、位号；
   2. 将相应的二进制位设为 “0”。

- **优点**：
  - 连续分配、离散分配都适用。
  - 很容易在位示图中找到一个或一组相邻接的空闲盘块。
  - 位示图很小，占用空间少，因此可将它保存在内存中，从而节省许多磁盘启动的开销。

- **缺点**：位示图大小会随着磁盘容量的增加而增大。适用于小型计算机。



## （四）成组链接法

空闲表法、空闲链表法不适用于大型文件系统，因为空闲表或空闲链表可能过大。UNIX 系统中采用了 **成组链接法** 对磁盘空闲块进行管理。

**成组链接法** 会在 **文件卷的目录区中** 专门用一个磁盘块作为 **超级块**，当系统启动时需要将 **超级块读入内存**。并且要保证内存与外存中的“超级块”数据一致。

1. **思想**：每组（除了最后一组）的第一块作为索引块，然后将这些索引块链接起来。
   - 将空闲盘块分成若干组，每组的第一个盘块记录下一组的空闲盘块总数和空闲盘块号。
   - 由各组的第一个盘块，可以链接成一条链。
   - 第一组的空闲盘块总数和空闲盘块号保存在内存的专用栈中，即 **空闲盘块号栈（超级块）**。

*注意*：
   - 若已经没有下一组空闲块，则该块中存放的第一个盘块号是一个特殊值（如：-1），作为空闲盘块链的结束标志。
   - 一个分组中的盘块号可以不需要连续。

2. **盘块的分配**
   1. 根据空闲盘块栈（超级块）的指针，将与指针对应的盘块分配给用户，同时移动指针，并将栈中的空闲盘块数减 1。
   2. 若 **超级块中的指针** 指向的是 **栈底的盘块号**，这个盘块号对应的盘块中 **保存着下一组空闲的盘块号**，所以要 **将这个下一组盘块的内容读入栈（超级块）中**，作为新的空闲盘块号栈（超级块）的 **内容**，并将原栈底盘块号对应的盘块分配出去。

3. **盘块的回收**
   1. 将回收的盘块号存入空闲盘块号栈（超级块）的顶部，同时移动指针，并将栈中的空闲盘块数加 1。
   2. 当栈中的空闲盘块数已达一组的数量上限时，表示栈已满。
      - 将现有栈中的所有空闲盘块号存入新回收的盘块，并将该新回收的盘块号作为新栈底，再将栈中的空闲盘块数置为 1。





# 六、文件控制块（FCB）

**文件控制块（FCB）** 时用来存放控制文件需要的各种信息的数据结构。实现了文件名和文件之间的映射，使用户（用户程序）可以实现 **按名存取**。

- 文件与 FCB 一一对应。

**文件目录**：FCB 的有序集合。

**文件目录项**：一个FCB。

**目录文件**：一个文件目录也被视为一个文件。

- 每当创建一个新文件，系统就要为其建立一个 FCB，用来记录文件的各种属性。

|一个典型的 FCB|
|:-----------:|
|文件名|
|类型|
|文件权限（读，写）|
|文件大小|
|文件数据块指针|

- FCB 主要包含：
  - **基本信息**：**文件名**、**文件的物理位置**、文件的逻辑结构、文件的物理结构等。
  - **存取控制信息**：文件主的存取权限、核准用户的存取权限、一般用户的存取权限。
  - **使用信息**：文件建立时间、上次修改时间等。






# 七、索引结点（FCB 的改进）

在检索目录时，文件的其他描述信息不会用到，也比需要调入内存。便可采用 **文件名和文件描述信息分离** 的方法，使 **文件描述信息单独形成** 一个称为 **索引节点（i 节点）** 的数据结构。

- 在文件目录中的每个 **目录项** 仅由 **文件名** 和相应的 **索引节点号（索引节点指针）** 构成。

    |文件名|索引节点指针|
    |:---:|:----------:|

- 由于目录项减小，因此每个磁盘块可以存放更多个目录项，因此检索文件时磁盘 I/O 的次数就少了很多。

- **磁盘索引节点**：存放在磁盘上的索引节点。
  - 每个文件有一个唯一的磁盘索引节点。
  - 主要包括：
    - **文件主标识符**：拥有该文件的个人或小组的标识符。
    - **文件类型**：包括普通文件、目录文件、特别文件。
    - **文件存取权限**：各类用户对该文件的存取权限。
    - **文件物理地址**：每个索引节点中含有 13 个地址项，即 iaddr(0) ~ iaddr(12)，它们以直接或间接方式给出数据文件所在盘块的编号。
    - **文件长度**：以字节为单位的文件长度。
    - **文件链接计数**：在本文件系统中所有指向该文件的文件名的指针计数。
    - **文件存取时间**：本文件最近被进程存取、修改的时间及索引节点最近被修改的时间。

- **内存索引节点**：存放在内存中的索引节点。
  - 当文件被打开时，要将磁盘索引节点复制到内存的索引节点中，便于以后使用。
  - 在 **内存索引节点中需要增加一些信息**：
    - **索引节点号**：用于标识内存索引节点。
    - **状态**：指示 i 节点是否上锁或被修改。
    - **访问计数**：每当有一进程要访问此 i 节点时，计数加 1；访问结束减 1。
    - **逻辑设备号**：文件所属文件系统的逻辑设备号。
    - **链接指针**：设置分别指向空闲链表和散列队列的指针。





# 八、目录

## （一）目录的基本概念

一个文件对应一个 **FCB**，**文件目录** 是 FCB 的有序集合。一个 FCB 就是一个 **文件目录项**。




## （二）目录的操作

1. **搜索**：当用户要使用一个文件时，系统要根据文件名搜索目录，找到该文件对应的目录项。
2. **创建文件**：创建一个新文件时，需要在其所属的目录中增加一个目录项。
3. **删除文件**：当删除一个文件时，需要在目录中删除相应的目录项。
4. **创建目录**：在树形目录结构中，用户可创建自己的用户文件目录，并可再创建子目录。
5. **删除目录**：有两种方式
   1. 不删除非空目录，删除时要先删除目录中的所有文件，并递归地删除子目录。
   2. 可删除非空目录，目录中的文件和子目录同时被删除。
6. **移动目录**：将文件或子目录在不同的父目录之间移动，文件的路径名也会随之改变。
7. **显示目录**：用户可以请求显示目录的内容，如显示该目录中的所有文件及相应属性。
8. **修改目录**：某些文件属性保存在目录中，因此这些属性变化时需要修改相应的目录项。（如：文件重命名）




## （三）目录结构

### 1. 单极目录结构

在整个文件系统中只建立一张目录表，每个文件占一个目录项。

- 在创建一个文件时，需要先检查目录表中有没有重名文件，确定不重名后才能允许建立文件，并将新文件对应的目录项插入目录表中。

- **优点**：实现了 **按名存取**。

- **缺点**：
  - 查找速度慢
  - **文件不允许重名**
  - 不便于文件共享
  - 不适用于多用户的操作系统



### 2. 两级目录结构

**两级目录结构** 将文件目录分成 **主文件目录（MFD，Master File Directory）** 和 **用户文件目录（UFD，User File Directory）** 两级。

- **主文件目录项** 记录用户名以及相应用户文件目录所在的存储位置。

- **用户文件目录项** 记录该用户所有文件的 PCB。

- **优点**：
  - 提高了检索的速度。
  - **允许不同用户的文件重名**。
  - 文件系统可以在目录上实现访问限制（检查此时登录的用户名是否匹配）。

- **缺点**：缺乏灵活性，用户 **不能对文件进行分类**。



### 3. 树形目录结构（多级目录结构）

树形目录结构中，用户（用户进程）要访问某个文件时，用文件的路径名标识文件。

- **文件路径名** 是个字符串，由从根目录出发到所找文件的通路上的所有目录名与数据文件名用分隔符 “/” 链接而成。
  - 系统中每个文件都有唯一的路径名。

- **绝对路径**：从根目录出发的路径。
  - 系统可以根据绝对路径一层一层地找到下一级目录。

当用户连续访问一个目录内的多个文件时，如果每次都从根目录开始查找，效率很低。因此设置可以为每个进程设置一个 **当前目录（工作目录）**。

- **相对路径**：从当前目录出发的路径。

- 引入 **当前目录** 和 **相对路径** 后，磁盘 I/O 的次数减少，提升了访问文件的效率。

- **优点**：
  - **方便对文件进行分类**
  - 层次结构清晰
  - 更有效地进行文件的管理和保护

- **缺点**：
  - **不便于实现文件的共享**
  - 降低查询速度。在树形目录中查找一个文件，需要按路径名逐级访问中间节点，增加了磁盘访问次数。



### 4. 无环图目录结构

**无环图目录结构** 在树形目录结构的基础上增加一些指向同一节点的有向边，使整个目录成为一个 **有向无环图**。

- **可以用不同的文件名指向同一个文件**，甚至可以指向同一个目录（共享同一目录下的所有内容）。

- 为每个共享节点设置一个 **共享计数器**，用于记录此时有多少个地方在共享该节点。
  - 每当用户提出共享节点的请求（增加对该节点的共享链）时，使 **共享计数器加 1**。
  - 每当用户提出删除共享节点的请求（减少对该节点的共享链）时，只是删除该用户的 FCB，并使 **共享计数器减 1**，并不会直接删除共享节点。
  - **只有共享计数器减为 0 时，才删除节点**。

*注意*：共享文件不同于复制文件。在 **共享文件中，由于各用户指向的是同一个文件，因此主要其中一个用户修改了文件数据，那么所有用户都可以看到文件数据的变化**。

- **优点**：**方便地实现了文件的共享**。

- **缺点**：使得系统的管理变得更加复杂。





# 九、文件的操作

操作系统提供了一系列系统调用，实现对文件的 **创建**、**删除**、**读**、**写**、**打开**、**关闭**

- 可用几个基本操作完成更复杂的操作。


## 1. 创建文件（create 系统调用）

- 进行 Creat 系统调用时，需要提供几个主要参数：
   - 所需的外存空间大小
   - 文件存放路径
   - 文件名
- 创建文件有两个必要步骤：
   1. **为新文件分配外存空间**
   2. 根据文件存放路径的信息找到该目录对应的目录文件，在目录中 **创建该文件对应的目录项**。目录项中包含了文件名、文件在外存中的存放位置等信息。




## 2. 删除文件（delete 系统调用）

- 进行 Delete 系统调用时，需要提供：
  - 文件存放路径
  - 文件名
- 操作系统在处理 Delete 系统调用时，主要做了：
  1. 根据文件存放路径找到相应的目录文件，从目录中 **找到文件名对应的目录项**。
  2. 根据该目录项记录的文件在外存存放的位置、文件大小等信息，**回收文件占用的磁盘块**。（回收磁盘块时，根据空闲表法、空闲链表法、位图法等管理策略的不同，需要做不同的处理）
  3. 从目录项中 **删除文件对应的目录项**。




## 3. 读文件（read 系统调用）

- 进行 Read 系统调用时，需要提供：
  - 是哪个文件（在支持“打开文件”操作的系统中，只需要提供文件在打开文件表中的索引号即可）
  - 读入多少数据
  - 读入的数据要放在内存中的什么位置。

- 操作系统在处理 Read 系统调用时，会从读指针指向的外存中，将用户指定大小的数据读入用户指定的内存区域中。（真正地把数据从外存读入内存）




## 4. 写文件（write 系统调用）

- 进行 Write 系统调用时，需要提供：
  - 是哪个文件（在支持“打开文件”操作的系统中，只需要提供文件在打开文件表中的索引号即可）
  - 要写入多少数据
  - 写回外存的数据放在内存的什么位置

- 操作系统在处理 Write 系统调用时，会从用户指定的内存区域中，将指定大小的数据写回指针指向的外存。




## 5. 打开文件（open 系统调用）

 - 进行 Open 系统调用时，需要提供：
   - 文件存放路径
   - 文件名
   - 要对文件的操作类型（如：r 只读；rw 读写等）
 - 操作系统在处理 Open 系统调用时，主要做了：
   1. 根据文件存放路径找到相应的目录文件，从目录中 **找到文件名对应的目录项**，并检查该用户是否有指定的操作权限。
   2. **将目录项复制到内存中的“打开文件表”中**。并将对应表目的编号（索引号/文件描述符）返回给用户。之后 **用户使用打开文件的编号来指明要操作的文件，不需要每次都重新查目录了**，可以增加文件的访问速度。
      - **打开文件表**：系统维护的一个包含所有打开文件信息的表。分为 **系统的打开文件表（整个系统只有一张）** 和 **用户进程的打开文件表**。
        - **系统的打开文件表**
          |编号|文件名|...|外存地址|打开计数器|
          |:-:|:----:|:-:|:-----:|:--------:|
          |k|test.txt|...|...|1|
            - **打开计数器**：记录此时有多少个进程打开了此文件。
            - 需要删除文件时，会先检查系统的打开文件表，确认此时是否有进程正在使用文件。
        - **用户进程的打开文件表**
          |编号|文件名|...|读写指针|访问权限|系统表索引号|
          |:-:|:----:|:-:|:-----:|:------:|:---------:|
          |1|test.txt|...|...|只读|k|
          - **读写指针** 记录该进程对文件的读/写操作进行到的位置。

**注意**：
  - 打开文件时并不会把文件数据直接写入内存。只是将目录项中的信息复制到内存中的打开文件表中。
  - **只要完成了文件打开 open() 系统调用**，后面在使用 read()、write()、Lseek()、close() 等文件操作的系统调用，**就不用再使用文件名，而使用文件描述符**。




## 6. 关闭文件（close 系统调用）

- 操作系统在处理 Close 系统调用时，主要做了：
  1. 将进程的打开文件表项删除
  2. 回收分配给文件的内存空间等资源
  3. 系统打开文件表的打开计数器减 1，若打开计数器为 0，则删除对应表项。





# 十、文件共享

操作系统为用户提供文件共享功能，可以让多个用户共享地使用同一个文件。

实现文件共享有两种方式：**基于索引节点的共享方式（硬链接）** 和 **基于符号链的共享方式（软链接）**。

**注意**：
  - 多个用户共享一个文件，意味着系统中其实只有“一份”文件数据。并且只要某个用户修改了该文件的数据，其他用户也可以看到文件数据的变化。
  - 如果是多个用户都“复制”了同一个文件，那么系统中会有“好几份”文件数据。其中一个用户修改了自己的那份文件数据，对其他用户的文件数据并没有影响。


## （一）基于索引节点的共享方式（硬链接）

**硬链接** 是基于节点的共享方式。
  - 将文件的物理地址和属性等信息不再放在目录项中，而是放在索引节点中，在目录中只设置 **文件名** 及  **指向索引节点的指针**。
  - 索引节点中设置一个 **链接计数 count（引用计数）**，表示链接到本索引节点（文件）上的用户目录项的数量。

- **使用方法**：
  - 当用户 A 创建一个新文件时，将 count 设置为 1。
  - 当用户 B 要共享此文件时，在 B 的目录中增加一个目录项，并设置一个指针指向该文件的索引节点。此时 count = 2。
  - 若有用户要删除此文件，则将此文件的 count 减 1，然后删除自己目录中的对应目录项。别的用户仍可使用此文件。
  - 当 count > 0时，说明还有别的用户要使用该文件，暂时不能把文件数据删除，否则会导致指针悬空。
  - 当 count = 0时，表示没有用户使用该文件，才删除该文件。




## （二）基于符号链的共享方式（软链接）

**软链接（符号链接）** 在一个 Link 型的文件中记录共享文件的存放路径。（类似 Windows 快捷方式）

- 只有文件主采用有指向其索引节点的指针。共享该文件的其他用户只有该文件的路径名，并不拥有指向该文件的索引节点的指针。

- 操作系统根据路径一层层查找目录，最终找到共享文件。

- 即使软链接指向的共享文件已被删除，Link 型文件依然存在，只是通过 Link 型文件中的路径去查找共享文件会失败（找不到对应目录项）。

- 由于用软链接的方式访问共享文件时要查询多级目录，会有多次磁盘 I/O，增大了访问文件的开销，因此软链接访问速度比硬链接的慢。

- 符号链接也是一个文件，其索引节点也要耗费一定的磁盘空间。

- 利用符号链实现网络文件共享时，只需要提供该文件所在机器的网络地址及文件路径名。





# 十一、文件保护

为了防止文件共享可能导致文件被破坏或未经核准的用户修改文件，文件系统必须控制用户对文件的存取，即解决对文件的读、写、执行的许可问题。

在文件系统中建立文件保护机制可以通过 **口令保护**、**加密保护**、**访问控制** 等方式实现。

- 口令和密码都是防止用户文件被他人存取或窃取，并没有控制用户对文件的服务类型。


## （一）口令保护

**口令保护** 为文件设置了一个“口令”，用户请求访问该文件时必须提供“口令”。

- 口令一般存放在文件对应的 FCB 或索引节点中。

- 用户访问文件前需要先输入“口令”，操作系统会将用户提供的口令与 FCB 中存储的口令进行对比，如果正确，则允许该用户访问文件。

- **优点**：保存口令的空间开销不多，验证口令的时间开销也很小。

- **缺点**：正确的“口令”存放在系统内部，不够安全。




## （二）加密保护

**加密保护** 使用某个“密码”对文件进行加密，在访问文件时需要提供正确的“密码”才能对文件进行正确的解密。（如：异或加密）

- **优点**：保密性强，不需要在系统中存储“密码”

- **缺点**：编码/译码（加密/解密）要花费一定时间。




## （三）访问控制

**访问控制** 在每个文件的 PCB（或索引节点）中增加一个 **访问控制列表（Access-Control List，ACL）**，该表中记录了各个用户可以对该文件执行哪些操作。

- 可加以控制的访问类型一般有：
  - 读：从文件中读数据
  - 写：向文件中写数据
  - 执行：将文件装入内存并执行
  - 添加：将新信息添加到文件结尾部分
  - 删除：删除文件，释放空间
  - 列表清单：列出文件名和文件属性

- 普通的访问控制列表的长度无法预计并且可能导致复杂的空间管理。可以用 **精简的访问列表** 来解决。

- **精简的访问列表** 以“组”为单位，标记各“组”用户可以对文件执行哪些操作。
  - 当用户想要访问文件时，系统会检查该用户所属的分组是否有相应的访问权限。
  - 精简的访问控制列表可采用拥有着、组、和其他三种用户类型：
    - **拥有者**：创建文件的用户。
    - **组**：一组需要共享文件且具有类似访问的用户。
    - **其他**：系统内的所有其他用户。

- 创建文件时，系统将文件拥有者的名字、所属组名记录在该文件的 FCB 中。

- 用户访问该文件时，若用户是文件主按照文件主所拥有的权限访问文件；

- 若用户和文件主在同一个用户组，则按照同组权限访问，否则只能按其他用户权限访问。

- **优点**：实现灵活，可以使用复杂的访问方法。

**注意**：如果对某个目录进行了访问权限的控制，那也要对目录下的所有文件进行相同的访问权限控制。





# 十二、文件系统

## （一）文件系统的概念

**文件管理系统（文件系统，File system）** 是操作系统中负责管理和存储文件信息的软件机构。提供高效和便捷的磁盘访问，以便允许存储、定位、提取数据。




## （二）文件系统的组成

文件系统由三部分 **组成**：
  - **与文件管理有关的文件**
  - **被管理文件**
  - **实施文件管理所需的数据结构**




## （三）文件系统的功能

文件系统要完成以下 **功能**：
  - 对于用户：
    - 实现对文件的基本操作。让用户可以按名存储和查找文件，组织成合适的结构。
    - 具有基本的文件共享功能
    - 具有基本的文件保护功能
  - 对于操作系统本身：
    - 管理与磁盘的信息交换
    - 完成文件逻辑结构和物理结构上的交换
    - 组织文件在磁盘上的存放
    - 采取好的文件排放顺序和磁盘调度方法以提升整个系统的性能。




## （四）文件系统的层次结构

```mermaid
graph TB
  1(用户/应用程序)
  2(用户接口)
  3(文件目录系统)
  4(存取控制模块)
  5(逻辑文件系统与文件信息缓冲区)
  6(物理文件系统)
  7(辅助分配模块)
  8(设备管理模块)
  9((设备))

  2 ==> 1
  3 ==> 2
  4 ==> 3
  5 ==> 4
  6 ==> 5

  1 ==> 2
  2 ==> 3
  3 ==> 4
  4 ==> 5
  5 ==> 6

  6 ==> 7 & 8
  7 ==> 6
  8 ==> 6

  8 ==> 9
  9 ==> 8

  linkStyle 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15 stroke:white
```

- **用户接口**：文件系统要向上层的用户提供一些简单易用的功能接口。这层就是用于处理用户发出的系统调用请求。（Read、Write、Open、Close 等系统调用）

- **文件目录系统**：用户是通过文件路径来访问文件的，因此这一层需要根据用户给出的文件路径找到相应的 FCB 或索引节点。
  - 所有和目录、目录项相关的管理工作都在本层完成。

- **存取控制模块**：为了保证文件数据的安全，还需要验证用户是否有访问权限。这一层主要完成了文件保护相关的功能。

- **逻辑文件系统与文件信息缓冲区**：用户指明想要访问的文件记录号，这一层需要将记录号转换为对应的逻辑地址。

- **物理文件系统**：这一层需要把上一层提供的文件逻辑地址转换为实际的物理地址。

- **辅助分配模块**：负责文件存储空间的管理，即负责分配和回收存储空间。

- **设备管理模块**：直接与硬件交互，负责和硬件之间相关的一些管理工作。




## （五）文件系统布局

### 1. 文件系统在磁盘中的结构

将原始磁盘内 **物理格式化（低级格式化）**，即划分扇区，检测坏扇区，并用备用扇区替换坏扇区。

物理格式化完成后，进行 **逻辑格式化（高级格式化）**。把磁盘分为一个个 **磁盘分区（分卷）**，完成各分区的文件系统初始化。

- 每个分区当中有各自独立的文件系统。

- 文件系统可能包括：
  - **主引导记录（Master Boot Record，MBR）**：位于磁盘的 0 号扇区，用来引导计算机。包含磁盘引导程序和分区表。
    - **分区表** 给出每个分区的起始和结束地址。表中的一个分区会被标记为 **活动分区**。
    - 当计算机启动时，BIOS 读入并执行 MBR。
    - MBR 首先会确定活动分区，读入它的第一块，即引导块。
  - **引导块（引导扇区）**：负责启动该分区中的操作系统。
    - 每个分区都是同一从一个引导块开始。
  - **超级块**：包含文件系统的所有关键信息。
    - 计算机启动时，或该文件系统首次使用时，超级块会被读入内存。
    - 主要是为了迅速地找到空闲块。
  - **文件系统中空闲块的信息**：可以用位示图或指针链接的形式给出。
    - 主要是记录空闲块信息。
  - **i 节点区（索引节点）**：每个文件对应一个节点。每个索引节点在这里是连续存放的，且每个大小都相同。
  - **根目录**：存放系统文件目录树的根部。
  - **其他所有的目录和文件**

- 磁盘：

  |主引导记录（MBR）<br>（包含：磁盘引导程序和分区表）|C: 盘|D：盘|E：盘|
  |:--------------:|:--:|:---:|:---:|

- C：盘：
  |引导块<br>（负责开机时初始化操作系统）|超级块|空闲空间管理<br>（如：位示图）|i 节点区|根目录|其他文件、目录|
  |:---:|:----:|:---------:|:-----:|:----:|:-----------:|

### 2. 文件系统在内存中的结构

内存中的信息用于管理文件系统和通过缓存来提高性能。

- 内存中的信息在安装文件系统时被加载，在文件系统操作期间被更新，在卸载时被丢弃。

1. **内存中的安装表**：包含每个已安装文件系统分区的有关信息。

2. **内存中的目录结构的缓存**：包含最近访问目录的信息。
   - 近期访问过的目录文件会缓存在内存中，不用每次都从磁盘读入，这样可以加快目录检索速度。

3. **整个系统的打开文件表**：包含每个打开文件的 FCB 副本、打开计数器及其他信息。

4. **每个进程的打开文件表**：包含进程打开文件的文件描述符和指向整个系统的打开文件表中对应表项的指针。





# 十三、虚拟文件系统

**虚拟文件系统（VFS）** 屏蔽了不同文件系统的差异和操作细节，向上为用户提供了文件操作的统一调用接口。

- **虚拟文件系统** 采用了面向对象的思想，抽象出一个通用的文件系统模型，定义了通用文件系统都支持的接口。
  - 新的文件系统主要支持并实现这些接口，即可安装和使用。

- 每打开一个文件，VFS 就在主存中新建一个 vnode，用统一的数据结构表示文件，无论该文件存储在哪个文件系统，并将文件信息复制到 vnode 中，vnode 的功能指针指向具体文件系统的函数功能。
*注意*：vnode 只存在于主存中，而 inode 既会被调入主存，也会在外存中存储。





# 十四、文件系统挂载

**文件系统挂载** 即文件系统的安装/装载。将一个文件系统挂载到操作系统中。

- **文件系统挂载需要做**：
  1. 在 VFS 中注册新挂载的文件系统。VFS 用 **内存中的挂载表** 来管理文件系统，包含每个文件系统的相关信息，包含文件系统类型、容量大小等。
  2. 新挂载的文件系统，要向 VFS 提供一个 **函数地址列表**。即每个文件系统的各个操作的系统调用存放位置。
  3. 将新文件系统加到 **挂载点**，即将新文件系统挂载在某个父目录下。